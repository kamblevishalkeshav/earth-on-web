<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Satellite Simulation - HTML Controls</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/style.css">
    <script src="https://unpkg.com/satellite.js@4.0.0/dist/satellite.min.js"></script>
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.176.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.176.0/examples/jsm/"
          }
        }
    </script>
</head>
<body>
<button id="menuToggleBtn">✕</button>
<div id="ob_menu"></div>
<div id="mercatorContainer">
    <div class="mapBackground">
        <canvas id="mercatorCanvas"></canvas>
    </div>
</div>

<script type="module">
    let usingLocalAssets;
    import * as THREE from 'three';
    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
    import {
        mercatorCanvasElement,
        mapBackgroundDiv,
        mercatorContainer,
        mapHeight,
        mapWidth,
        initMercatorView, updateMercatorMap
    } from './js/mercatorMapLoader.js';
    import {
        SATELLITES_BASE_URL,
        satelliteConfig,
        earthConfig,
        sceneConfig,
        controlsConfig,
        checkFileExists
    } from './js/SatelliteConfigurationLoader.js';
    import {updateSatelliteInfo, satelliteMenuLoader} from './js/SatelliteMenuLoader.js';
    import {showSatellite, buildAllBeams, clearCurrentDetailedSat, updateBusOrientation} from './js/satelliteModelLoader.js';
    import {addECEFAxes, update3DLabelsPosition, updateECEFAxesVisibility} from './js/EarthFrameLoader.js';
    import {createOrbitFrame, updateOrbitFrame, setOrbitFrameVisibility} from './js/orbitFrameLoader.js';
    import {KM_TO_SCENE_UNITS, EARTH_SCENE_RADIUS} from './js/SatelliteConstantLoader.js';
    import {satellites, updateOrbitTrajectory, setupTLESatellites, removeAllGeometry} from './js/satelliteTLELoader.js';
    import {createYPRFrame, updateYPRFrame, setYPRVisibility} from './js/SatelliteYawPitchRollLoader.js';

    // Load menu
    const versionNumber = "1.0j"; // Updated version
    const versionRepoUrl = "https://github.com/arcazj/openbexi_earth_orbit";
    const versionText = `version ${versionNumber} - hosted at`;
    document.getElementById('ob_menu').innerHTML = satelliteMenuLoader();

    let scene, camera, renderer, earthMesh, controls;
    let orbitFrame = null
    let currentSelectedSatellite = null; // This will store the TLE data object for the selected satellite
    let textureLoader;
    let detailedSatelliteModel = null; // This will store the THREE.Group from satelliteModelLoader
    let yprFrame;

    const simParams = {
        orbitTypeFilter: "MEO",
        companyFilter: "ALL COMPANY",
        selectedSatelliteName: "None", // Stores the name/ID from the dropdown
        showOrbit: false,
        view3D: true,
        viewMercator: false,
        useHighDefTexture: false,
        showECEFAxes: false,
        showOrbitFrame: false,
        yawDeg:   0,
        pitchDeg: 0,
        rollDeg:  0,
        showYPR:  false    // new checkbox you already wired
    };

    let orbitTypeFilterSelect, companyFilterSelect, satelliteCountDisplay;
    let view3DToggle, viewMercatorToggle, showOrbitToggle, showOrbitFrameToggle;
    let highDefToggleElement, showECEFAxesToggleElement, showOrbitFrameToggleElement;
    let satelliteSelectDropdown, satelliteInfoDiv;
    let controlsContainerElement, menuToggleBtnElement, versionDisplayElement;
    let labelXecrDiv, labelYecrDiv, labelZecrDiv, labelNorthPoleDiv, labelEquatorLineDiv, labelGreenwichMeridianDiv;

    function isMobileDevice() {
        return /Android|iPhone|iPad|iPod|BlackBerry|Windows Phone/i.test(navigator.userAgent || navigator.vendor || window.opera);
    }

    function updateEarthTexture() {
        if (!earthMesh || !textureLoader || !earthConfig) {
            console.warn("updateEarthTexture: Missing critical components.");
            return;
        }

        const textureToLoad = simParams.useHighDefTexture ? earthConfig.texture : earthConfig.textureLight;

        if (!textureToLoad) {
            console.error("Earth Texture URL is null. Check config paths and getFullGitHubUrl logic.");
            // Apply a very basic material if texture path is null
            earthMesh.material.map = null; // Remove any existing map
            earthMesh.material.color.set(0x1a237e); // A solid blue color
            earthMesh.material.needsUpdate = true;
            return;
        }
        console.log("Attempting to load Earth texture:", textureToLoad);

        textureLoader.load(textureToLoad,
            (texture) => {
                earthMesh.material.map = texture;
                earthMesh.material.color.set(0xffffff); // Reset color if texture loads
                earthMesh.material.needsUpdate = true;
                console.log("Earth texture successfully updated to:", textureToLoad);
            },
            undefined, // onProgress callback (optional)
            (err) => {
                //console.error('Error loading Earth texture from:', textureToLoad, err, '. Using placeholder.');
                // Fallback to a placeholder image from placehold.co
                const placeholderUrl = `https://placehold.co/${simParams.useHighDefTexture ? '4096x2048' : '1024x512'}/1c313a/ffffff?text=Earth+Texture+Load+Error`;
                textureLoader.load(placeholderUrl, (fallbackMap) => {
                    earthMesh.material.map = fallbackMap;
                    earthMesh.material.needsUpdate = true;
                });
            }
        );
    }

    function init3D() {
        /* ───────── Scene, Camera, Renderer ───────── */
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
            sceneConfig.camera.fov,
            window.innerWidth / window.innerHeight,
            sceneConfig.camera.near,
            sceneConfig.camera.far
        );
        camera.position.set(...sceneConfig.camera.position);

        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        /* expose for other modules (orbitFrame labels need them) */
        window.renderer = renderer;
        window.camera = camera;

        /* ───────── Lighting ───────── */
        scene.add(new THREE.AmbientLight(
            sceneConfig.ambientLight.color,
            sceneConfig.ambientLight.intensity
        ));

        const dirLight = new THREE.DirectionalLight(
            sceneConfig.directionalLight.color,
            sceneConfig.directionalLight.intensity
        );
        dirLight.position.set(...sceneConfig.directionalLight.position);
        scene.add(dirLight);

        /* ───────── Earth mesh ───────── */
        textureLoader = new THREE.TextureLoader();
        const earthMat = new THREE.MeshPhongMaterial({color: 0xffffff}); // texture applied later
        earthMesh = new THREE.Mesh(
            new THREE.SphereGeometry(EARTH_SCENE_RADIUS, 64, 64),
            earthMat
        );
        scene.add(earthMesh);
        updateEarthTexture();

        /* ───────── ECEF Axes (green) ───────── */
        addECEFAxes(scene);
        updateECEFAxesVisibility(simParams);

        /* ───────── LVLH Orbit‑Frame (hidden until user toggles) ───────── */
        orbitFrame = createOrbitFrame(scene);           // default 10 000 km length
        setOrbitFrameVisibility(orbitFrame, false);     // start invisible

        /* ───────── OrbitControls ───────── */
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = controlsConfig.enableDamping;
        controls.dampingFactor = controlsConfig.dampingFactor;
        controls.minDistance = EARTH_SCENE_RADIUS * 0.4;   // prevent inside‑Earth zoom
        controls.maxDistance = EARTH_SCENE_RADIUS * 20;    // generous zoom‑out
        controls.enableZoom = true;
    }

    function setupHTMLControls() {
        controlsContainerElement = document.getElementById('controlsContainer');
        menuToggleBtnElement = document.getElementById('menuToggleBtn');
        versionDisplayElement = document.getElementById('versionDisplay');

        if (versionDisplayElement) {
            const versionLink = document.createElement('a');
            versionLink.href = versionRepoUrl;
            versionLink.textContent = `GitHub Repo`;
            versionLink.target = "_blank"; // Open in new tab
            versionDisplayElement.textContent = `${versionText} `;
            versionDisplayElement.appendChild(versionLink);
        }


        orbitTypeFilterSelect = document.getElementById('orbitTypeFilter');
        companyFilterSelect = document.getElementById('companyFilter');
        satelliteCountDisplay = document.getElementById('satelliteCountDisplay');

        view3DToggle = document.getElementById('view3DToggle');
        viewMercatorToggle = document.getElementById('viewMercatorToggle');
        highDefToggleElement = document.getElementById('highDefToggle');
        showECEFAxesToggleElement = document.getElementById('showECEFAxesToggle');
        showOrbitFrameToggleElement = document.getElementById('showOrbitFrameToggle');
        showOrbitToggle = document.getElementById('showOrbitToggle');

        satelliteSelectDropdown = document.getElementById('satelliteSelect');
        satelliteInfoDiv = document.getElementById('satelliteInfo');

        // Axis labels
        labelXecrDiv = document.getElementById('labelXecr');
        labelYecrDiv = document.getElementById('labelYecr');
        labelZecrDiv = document.getElementById('labelZecr');
        labelNorthPoleDiv = document.getElementById('labelNorthPole');
        labelEquatorLineDiv = document.getElementById('labelEquatorLine');
        labelGreenwichMeridianDiv = document.getElementById('labelGreenwichMeridian');

        // Pitch-Roll-Yaw
        const yprControls      = document.getElementById('yprControls');
        const yawSlider        = document.getElementById('yawSlider');
        const pitchSlider      = document.getElementById('pitchSlider');
        const rollSlider       = document.getElementById('rollSlider');
        const yawVal           = document.getElementById('yawVal');
        const pitchVal         = document.getElementById('pitchVal');
        const rollVal          = document.getElementById('rollVal');


        // Set initial values from simParams
        orbitTypeFilterSelect.value = simParams.orbitTypeFilter;
        view3DToggle.checked = simParams.view3D;
        viewMercatorToggle.checked = simParams.viewMercator;
        if (highDefToggleElement) highDefToggleElement.checked = simParams.useHighDefTexture;
        if (showECEFAxesToggleElement) showECEFAxesToggleElement.checked = simParams.showECEFAxes;
        if (showOrbitFrameToggleElement) showOrbitFrameToggleElement.checked = simParams.showOrbitFrame;
        showOrbitToggle.checked = simParams.showOrbit;

        // Event Listeners
        orbitTypeFilterSelect.addEventListener('change', (e) => {
            simParams.orbitTypeFilter = e.target.value;
            simParams.showOrbit = false; // Reset orbit display on filter change
            if (showOrbitToggle) showOrbitToggle.checked = false;
            removeAllGeometry(scene); // Clear orbit lines etc.
            updateSatelliteList(); // Refilter and update display
        });

        companyFilterSelect.addEventListener('change', (e) => {
            simParams.companyFilter = e.target.value;
            simParams.showOrbit = false; // Reset orbit display
            if (showOrbitToggle) showOrbitToggle.checked = false;
            removeAllGeometry(scene);
            updateSatelliteList();
        });

        view3DToggle.addEventListener('change', (e) => simParams.view3D = e.target.checked);
        viewMercatorToggle.addEventListener('change', (e) => simParams.viewMercator = e.target.checked);

        if (highDefToggleElement) {
            highDefToggleElement.addEventListener('change', (e) => {
                simParams.useHighDefTexture = e.target.checked;
                updateEarthTexture(); // Reload Earth texture
            });
        }
        if (showECEFAxesToggleElement) {
            showECEFAxesToggleElement.addEventListener('change', (e) => {
                simParams.showECEFAxes = e.target.checked;
                updateECEFAxesVisibility(simParams); // Toggle axes and labels
            });
        }

        if (showOrbitFrameToggleElement) {
            showOrbitFrameToggleElement.addEventListener('change', e => {
                simParams.showOrbitFrame = e.target.checked;
                if (orbitFrame) setOrbitFrameVisibility(orbitFrame, simParams.showOrbitFrame);
            });
        }

        showOrbitToggle.addEventListener('change', (e) => {
            simParams.showOrbit = e.target.checked;
            if (currentSelectedSatellite) { // Check if a satellite object is selected
                updateOrbitTrajectory(scene, simParams, currentSelectedSatellite); // Pass the satellite data object
            } else if (simParams.showOrbit) {
                // If showOrbit is checked but no satellite is selected, uncheck it
                simParams.showOrbit = false;
                e.target.checked = false;
                // Optionally, inform the user to select a satellite first
            }
        });

        satelliteSelectDropdown.addEventListener('change', handleSatelliteDropdownChange);

        const showYPRToggle = document.getElementById('showYPRToggle');
        showYPRToggle.addEventListener('change', e => {
            const v = e.target.checked;
            simParams.showYPR = v;
            setYPRVisibility(yprFrame, v);
        });
        function updateYPRLabels() {
            yawVal.textContent   = simParams.yawDeg.toFixed(1);
            pitchVal.textContent = simParams.pitchDeg.toFixed(1);
            rollVal.textContent  = simParams.rollDeg.toFixed(1);
        }
        [yawSlider, pitchSlider, rollSlider].forEach(sl => {
            sl.addEventListener('input', () => {
                simParams.yawDeg   = parseFloat(yawSlider.value);
                simParams.pitchDeg = parseFloat(pitchSlider.value);
                simParams.rollDeg  = parseFloat(rollSlider.value);
                updateYPRLabels();
                updateBusOrientation(detailedSatelliteModel, simParams.yawDeg, simParams.pitchDeg, simParams.rollDeg);
            });
        });
        updateYPRLabels();





        // Collapsible sections
        document.querySelectorAll('#controlsContainer h3[data-collapsible-target]').forEach(header => {
            const targetId = header.dataset.collapsibleTarget;
            const targetContent = document.getElementById(targetId);
            const icon = header.querySelector('.toggle-icon');

            if (targetContent && icon) {
                // Default to expanded
                targetContent.classList.remove('collapsed');
                icon.classList.remove('collapsed');
                icon.textContent = '▾'; // Down arrow for expanded

                header.addEventListener('click', () => {
                    targetContent.classList.toggle('collapsed');
                    icon.classList.toggle('collapsed');
                    icon.textContent = targetContent.classList.contains('collapsed') ? '▸' : '▾'; // Right for collapsed, Down for expanded
                });
            }
        });

        // Menu toggle button
        if (menuToggleBtnElement && controlsContainerElement) {
            menuToggleBtnElement.addEventListener('click', () => {
                controlsContainerElement.classList.toggle('menu-hidden');
                menuToggleBtnElement.innerHTML = controlsContainerElement.classList.contains('menu-hidden') ? '☰' : '✕'; // Hamburger or X
            });
            // Set initial state based on class (e.g., if 'menu-hidden' is default)
            menuToggleBtnElement.innerHTML = controlsContainerElement.classList.contains('menu-hidden') ? '☰' : '✕';
        }
    }

    async function handleSatelliteDropdownChange(event) {
        const selectedNameInDropdown = event.target.value; // This is satellite_name or "None"
        simParams.selectedSatelliteName = selectedNameInDropdown;

        // If a detailed model was previously shown, ensure its corresponding TLE sprite is made visible again.
        if (detailedSatelliteModel && detailedSatelliteModel.userData && detailedSatelliteModel.userData.noradId) {
            const prevTleSat = satellites.find(s => s.norad_id.toString() === detailedSatelliteModel.userData.noradId.toString());
            if (prevTleSat && prevTleSat.mesh) {
                prevTleSat.mesh.visible = true; // Make TLE sprite visible
                prevTleSat.isSelected = false;
                // Reset visual cues for the TLE sprite if any were changed
                prevTleSat.mesh.material.color.set(0xffffff);
                prevTleSat.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]));
            }
        }

        clearDetailedSatelliteView(); // Clears current detailed model from scene
        removeAllGeometry(scene); // Clears orbit lines

        if (selectedNameInDropdown === "None") {
            currentSelectedSatellite = null; // No TLE data object selected
            updateSatelliteInfo(satelliteInfoDiv, null);
            resetCameraToDefault();
            // Ensure all TLE sprites are reset visually if needed (updateSatelliteList handles this based on currentSelectedSatellite)
            updateSatelliteList(); // This will ensure correct visual state for sprites
            return;
        }

        // Find the satellite data object from the `satellites` array by its name
        const tleSatData = satellites.find(s => s.satellite_name === selectedNameInDropdown && s.mesh && s.mesh.visible);

        if (!tleSatData) {
            console.warn(`Satellite named "${selectedNameInDropdown}" not found or not visible in current filter.`);
            currentSelectedSatellite = null;
            updateSatelliteInfo(satelliteInfoDiv, null);
            // Potentially reset dropdown to "None" if the selected satellite is no longer valid
            if (satelliteSelectDropdown) satelliteSelectDropdown.value = "None";
            simParams.selectedSatelliteName = "None";
            return;
        }

        currentSelectedSatellite = tleSatData; // Store the actual satellite data object
        updateSatelliteInfo(satelliteInfoDiv, tleSatData);
        if (simParams.showOrbit) {
            updateOrbitTrajectory(scene, simParams, tleSatData);
        }

        // Attempt to load the detailed model
        let fileUrl = (usingLocalAssets ? "json/satellites/" : SATELLITES_BASE_URL) + `${tleSatData.norad_id}.json`;

        let fileExists = await checkFileExists(fileUrl);
        if (!fileExists && !usingLocalAssets) { // If GitHub primary fails, try GitHub backup structure if one existed
            console.warn(`Primary model file ${fileUrl} not found.`);
        }


        if (!fileExists && usingLocalAssets) { // If primary (which is local if usingLocalAssets) fails
            console.warn(`Local model file ${fileUrl} not found.`);
            // No other place to check if already local
        } else if (!fileExists && !usingLocalAssets) { // If primary GitHub failed, now try local path as a general fallback
            console.warn(`GitHub model file ${fileUrl} not found, attempting local fallback.`);
            fileUrl = "json/satellites/" + `${tleSatData.norad_id}.json`; // Standard local path
            fileExists = await checkFileExists(fileUrl);
        }


        if (fileExists) {
            await loadAndDisplayDetailedSatellite(tleSatData.norad_id, tleSatData);
        } else {
            // If no specific model, try loading a generic/default model (e.g., noradId "0" or "default")
            console.warn(`Satellite data file for NORAD ${tleSatData.norad_id} not found at any checked location. Attempting to load default model.`);
            // Before loading default, ensure the selected TLE sprite is correctly highlighted
            selectSatelliteSprite(tleSatData); // Visually select the TLE sprite
            flyCameraToSatellite(tleSatData.mesh, 1000, true); // Fly to the TLE sprite

            // Optionally, try to load a "default.json" or "0.json" if you have one
            // For now, we just log and don't load a detailed model if specific one not found.
            // await loadAndDisplayDetailedSatellite("0", null); // Pass null for tleData if it's a generic model
        }

        if (selectedNameInDropdown === "None") {
            yprControls.style.display = 'none';
        } else {
            yprControls.style.display = 'block';
        }

    }

    async function loadAndDisplayDetailedSatellite(noradId, tleSatData) {
        console.log(`Attempting to load detailed model for NORAD ID: ${noradId}`);
        const newModel = await showSatellite(noradId, scene);
        const newbeams = await buildAllBeams(noradId, currentSelectedSatellite, newModel.userData.payload.transponders);

        if (newModel) {
            detailedSatelliteModel = newModel; // Store the THREE.Group
            detailedSatelliteModel.userData.noradId = noradId; // Ensure NORAD ID is stored on the model

            if (tleSatData && tleSatData.satrec) {
                currentSelectedSatellite = tleSatData; // This is the TLE data object
                tleSatData.isSelected = true; // Mark TLE data as selected
                if (tleSatData.mesh) {
                    tleSatData.mesh.visible = false; // Hide the corresponding TLE sprite
                }

                // --- Set initial position of the detailed model ---
                const now = new Date();
                const jdayNow = satellite.jday(now.getUTCFullYear(), now.getUTCMonth() + 1, now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds());
                const gmstNow = satellite.gstime(jdayNow);
                try {
                    const posVel = satellite.propagate(tleSatData.satrec, now);
                    if (posVel && posVel.position) {
                        const ecf = satellite.eciToEcf(posVel.position, gmstNow);
                        detailedSatelliteModel.position.set(ecf.x * KM_TO_SCENE_UNITS, ecf.z * KM_TO_SCENE_UNITS, ecf.y * KM_TO_SCENE_UNITS);
                        console.log(`[Detailed Model] Initial position set for ${noradId}:`, detailedSatelliteModel.position);
                    } else {
                        console.warn(`[Detailed Model] Propagation failed for initial position of ${noradId}. Model at origin.`);
                    }
                } catch (e) {
                    console.error(`[Detailed Model] Error propagating TLE for initial position of ${noradId}:`, e);
                }
                // --- End set initial position ---

            } else {
                console.warn(`[Detailed Model] TLE data or satrec missing for NORAD ${noradId}. Model loaded at origin, cannot track orbit.`);
                currentSelectedSatellite = null; // No TLE data to track
            }
            if (newbeams) {
                scene.add(newbeams);
            }

            // Deselect other TLE sprites
            satellites.forEach(s => {
                if (s !== tleSatData && s.mesh) {
                    s.isSelected = false;
                    s.mesh.material.color.set(0xffffff); // Reset color
                    s.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1])); // Reset scale
                }
            });

            flyCameraToSatellite(tleSatData.mesh, 3000, false); // Fly to the detailed model itself
            if (simParams.showOrbit && currentSelectedSatellite) {
                updateOrbitTrajectory(scene, simParams, currentSelectedSatellite);
            }

        } else {
            console.error("Failed to load detailed satellite model for NORAD ID:", noradId, "(showSatellite returned null)");
            // Fallback: ensure the TLE sprite for this satellite is selected and camera flies to it.
            if (tleSatData) {
                selectSatelliteSprite(tleSatData); // Visually select the TLE sprite
                if (tleSatData.mesh) flyCameraToSatellite(tleSatData.mesh, 1000, true); // Fly to the TLE sprite
            } else {
                if (satelliteSelectDropdown) satelliteSelectDropdown.value = "None";
                simParams.selectedSatelliteName = "None";
                currentSelectedSatellite = null;
                resetCameraToDefault();
            }
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = "position:fixed; top:10px; left:10px; padding:10px; background:orange; color:black; z-index:1000;";
            errorDiv.innerText = `Failed to load 3D model for satellite NORAD ID: ${noradId}. Displaying TLE marker.`;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 5000);
        }
    }

    function clearDetailedSatelliteView() {
        if (detailedSatelliteModel) {
            const oldNoradId = detailedSatelliteModel.userData ? detailedSatelliteModel.userData.noradId : null;
            clearCurrentDetailedSat(scene);
            scene.remove(detailedSatelliteModel);
            detailedSatelliteModel = null;

            // If a TLE sprite was hidden for this detailed model, make it visible again
            if (oldNoradId) {
                const tleSat = satellites.find(s => s.norad_id.toString() === oldNoradId.toString());
                if (tleSat && tleSat.mesh) {
                    tleSat.mesh.visible = true;
                    // Ensure its isSelected state is false if another sat isn't immediately selected
                    // This is typically handled by updateSatelliteList or selection logic
                }
            }
        }
    }


    const clock = new THREE.Clock();
    let cameraMove = null;

    /**
     * Smooth flight from the current camera position to either a sprite or a
     * detailed satellite model.  For models, we frame them at *least* the same
     * distance used for sprites so the view is consistent.
     *
     * @param {THREE.Object3D} targetObject  The sprite or model to frame.
     * @param {number} [millis=1500]         Flight duration in ms.
     * @param {boolean} [isSprite=false]     Pass true when targetObject is a sprite.
     */
    /**
     * Smooth flight from the current camera position to either a sprite or a
     * detailed satellite model.  For models, we frame them at *least* the same
     * distance used for sprites so the view is consistent.
     *
     * @param {THREE.Object3D} targetObject  The sprite or model to frame.
     * @param {number} [millis=1500]         Flight duration in ms.
     * @param {boolean} [isSprite=false]     Pass true when targetObject is a sprite.
     */
    function flyCameraToSatellite(targetObject, millis = 1500, isSprite = false) {
        if (!targetObject || !camera || !controls) {
            console.warn("flyCameraToSatellite: Missing target, camera, or controls.");
            return;
        }

        const earthCenter = new THREE.Vector3(0, 0, 0);
        const targetPos = new THREE.Vector3().setFromMatrixPosition(targetObject.matrixWorld);
        const dirToTarget = new THREE.Vector3().subVectors(targetPos, earthCenter).normalize();

        let distance;

        /* ---------- sprite path ---------- */
        if (isSprite) {
            distance = EARTH_SCENE_RADIUS * 0.5;          // fixed offset
        }

        /* ---------- detailed‑model path ---------- */
        else {
            // Estimate model diameter then back off ~3× that size
            const bbox = new THREE.Box3().setFromObject(targetObject);
            const size = new THREE.Vector3();
            bbox.getSize(size);
            const modelDiameter = Math.max(size.x, size.y, size.z, 0.5 * KM_TO_SCENE_UNITS * 1000);
            distance = modelDiameter * 45;

            // Make sure we never get *closer* than the sprite framing distance
            distance = Math.max(distance, EARTH_SCENE_RADIUS * 0.5);
        }

        // Final camera position = target position + outward offset
        const endCamPos = new THREE.Vector3().addVectors(
            targetPos,
            dirToTarget.clone().multiplyScalar(distance)
        );

        /* ---------- animation set‑up ---------- */
        const startCamPos = camera.position.clone();
        const startTarget = controls.target.clone();
        const endTarget = targetPos.clone();               // always look at the sat

        cameraMove = {
            startTime: clock.getElapsedTime(),
            duration: millis / 1000,
            startCamPos,
            endCamPos,
            startTarget,
            endTarget
        };

        controls.enabled = false; // re‑enabled when the flight completes
    }

    function resetCameraToDefault() {
        if (camera && controls && sceneConfig && sceneConfig.camera && sceneConfig.camera.position) {
            // Stop any ongoing camera flight
            cameraMove = null;

            const startCamPos = camera.position.clone();
            const endCamPos = new THREE.Vector3(...sceneConfig.camera.position);
            const startTarget = controls.target.clone();
            const endTarget = new THREE.Vector3(0, 0, 0); // Look at Earth center

            cameraMove = {
                startTime: clock.getElapsedTime(),
                duration: 1.0, // 1 second to reset
                startCamPos, endCamPos,
                startTarget, endTarget
            };
            controls.enabled = false; // Disable during animation, re-enable in animate loop
        } else {
            console.warn("Cannot reset camera: camera, controls, or sceneConfig not fully initialized.");
        }
    }

    function updateSatelliteList() {
        if (!satellites || !satelliteSelectDropdown || !companyFilterSelect) {
            console.warn("updateSatelliteList: DOM elements not ready or satellites not loaded.");
            if (satelliteCountDisplay) satelliteCountDisplay.textContent = '0';
            if (satelliteSelectDropdown) satelliteSelectDropdown.innerHTML = '<option value="None">None</option>';
            if (companyFilterSelect) {
                const currentCompanyVal = companyFilterSelect.value;
                companyFilterSelect.innerHTML = '<option value="ALL COMPANY">ALL COMPANY</option>';
                if (currentCompanyVal !== "ALL COMPANY") { // Try to preserve if it was specific
                    const opt = document.createElement('option');
                    opt.value = currentCompanyVal;
                    opt.textContent = currentCompanyVal;
                    companyFilterSelect.appendChild(opt);
                    companyFilterSelect.value = currentCompanyVal;
                }
            }
            return;
        }

        const filteredTLEs = satellites.filter(s =>
            (simParams.orbitTypeFilter === "ALL" || s.orbitType === simParams.orbitTypeFilter) &&
            (simParams.companyFilter === "ALL COMPANY" || s.company === simParams.companyFilter)
        );

        // Update visibility of TLE sprites
        satellites.forEach(s => {
            if (s.mesh) {
                const isVisibleInFilter = filteredTLEs.includes(s);
                // A TLE sprite is visible if it's in the current filter AND
                // (EITHER no detailed model is shown OR the detailed model shown is NOT this TLE sprite's satellite)
                const isDetailedModelForThisSat = detailedSatelliteModel && detailedSatelliteModel.userData && detailedSatelliteModel.userData.noradId === s.norad_id.toString();
                s.mesh.visible = isVisibleInFilter && !isDetailedModelForThisSat;

                if (s.mesh.visible) { // Apply visual cues only if the sprite is visible
                    const isActuallySelected = currentSelectedSatellite === s; // s is the TLE data object
                    s.mesh.material.color.set(isActuallySelected ? 0xff0000 : 0xffffff); // Red if selected, white otherwise
                    const baseScale = satelliteConfig.scale || [0.1, 0.1, 0.1];
                    s.mesh.scale.set(...(isActuallySelected ? baseScale.map(v => v * 1.5) : baseScale));
                }
            }
        });


        if (satelliteCountDisplay) satelliteCountDisplay.textContent = filteredTLEs.length.toString();

        // Repopulate company filter based on *all* satellites, not just filtered ones, to allow broader selection
        const uniqueCompanies = Array.from(new Set(satellites.map(s => s.company))).sort();
        const currentCompanySelection = companyFilterSelect.value; // Preserve current selection if possible
        companyFilterSelect.innerHTML = '<option value="ALL COMPANY">ALL COMPANY</option>';
        uniqueCompanies.forEach(comp => {
            if (comp && comp !== "N/A") { // Filter out "N/A" or empty company names if desired
                const option = document.createElement('option');
                option.value = comp;
                option.textContent = comp;
                companyFilterSelect.appendChild(option);
            }
        });
        // Try to restore previous selection, or default to "ALL COMPANY"
        if (uniqueCompanies.includes(currentCompanySelection)) {
            companyFilterSelect.value = currentCompanySelection;
        } else {
            companyFilterSelect.value = "ALL COMPANY"; // Default if previous selection is no longer valid
            // simParams.companyFilter = "ALL COMPANY"; // Also update simParams if it changed
        }


        // Repopulate satellite dropdown based on *filtered* TLEs
        const currentDropdownValue = satelliteSelectDropdown.value; // Name of the satellite
        satelliteSelectDropdown.innerHTML = '<option value="None">None</option>';
        filteredTLEs.forEach(s => {
            const option = document.createElement('option');
            option.value = s.satellite_name; // Value is the name
            option.textContent = s.satellite_name;
            satelliteSelectDropdown.appendChild(option);
        });

        // Try to restore selection in dropdown
        if (filteredTLEs.some(s => s.satellite_name === currentDropdownValue)) {
            satelliteSelectDropdown.value = currentDropdownValue;
        } else {
            // If the previously selected satellite is no longer in the filtered list
            satelliteSelectDropdown.value = "None";
            simParams.selectedSatelliteName = "None";
            if (currentSelectedSatellite && !filteredTLEs.includes(currentSelectedSatellite)) {
                // If the actual selected object is no longer in filter, deselect it
                clearDetailedSatelliteView(); // Clear detailed model if it was for this sat
                selectSatelliteSprite(null); // Deselect TLE sprite
                currentSelectedSatellite = null;
                updateSatelliteInfo(satelliteInfoDiv, null);
            }
        }
        // If dropdown is "None" but a detailed model is showing, ensure consistency
        if (satelliteSelectDropdown.value === "None" && detailedSatelliteModel) {
            // This case should ideally be handled by the logic that sets dropdown to "None"
            // but as a safeguard:
            clearDetailedSatelliteView();
            currentSelectedSatellite = null;
            updateSatelliteInfo(satelliteInfoDiv, null);
        }
    }

    // Selects the TLE sprite (visual changes)
    function selectSatelliteSprite(tleSatData) {
        // Deselect any previously selected TLE sprite
        satellites.forEach(s => {
            if (s.mesh && s.isSelected) {
                s.isSelected = false;
                if (s.mesh.visible) { // Only change if visible
                    s.mesh.material.color.set(0xffffff);
                    s.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]));
                }
            }
        });

        currentSelectedSatellite = tleSatData; // Store the TLE data object

        if (tleSatData && tleSatData.mesh) {
            tleSatData.isSelected = true;
            if (tleSatData.mesh.visible) { // Only change if visible
                tleSatData.mesh.material.color.set(0xff0000); // Red
                tleSatData.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]).map(v => v * 1.5)); // Larger
            }
            simParams.selectedSatelliteName = tleSatData.satellite_name;
            if (satelliteSelectDropdown) satelliteSelectDropdown.value = tleSatData.satellite_name;
            updateOrbitTrajectory(scene, simParams, tleSatData);
        } else {
            // Deselecting
            simParams.selectedSatelliteName = "None";
            if (satelliteSelectDropdown) satelliteSelectDropdown.value = "None";
            removeAllGeometry(scene); // Clear orbit line
        }
        updateSatelliteInfo(satelliteInfoDiv, tleSatData); // Update text info panel
    }

    window.addEventListener('keydown', e => {
        if (e.key === 'r') {            // press “r” to reset
            controls.reset();             // OrbitControls’ built‑in reset
            camera.position.set(...sceneConfig.camera.position);
            controls.target.set(0, 0, 0);
        }
    });

    function animate() {
        requestAnimationFrame(animate);// time since last frame

        /*──────────────── Camera easing ────────────────*/
        if (cameraMove) {
            const now = clock.getElapsedTime();
            const t = Math.min((now - cameraMove.startTime) / cameraMove.duration, 1);
            const smooth = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;     // ease‑in‑out quad
            camera.position.lerpVectors(cameraMove.startCamPos, cameraMove.endCamPos, smooth);
            controls.target.lerpVectors(cameraMove.startTarget, cameraMove.endTarget, smooth);
            controls.update();

            if (t >= 1) {                          // flight complete
                cameraMove = null;
                controls.enabled = true;
            }
        } else if (controls && controls.enabled) {
            controls.update();
        }

        /*──────────────── Time & GMST ────────────────*/
        const currentTime = new Date();
        const jdayCurrent = satellite.jday(
            currentTime.getUTCFullYear(), currentTime.getUTCMonth() + 1, currentTime.getUTCDate(),
            currentTime.getUTCHours(), currentTime.getUTCMinutes(), currentTime.getUTCSeconds());
        const gmstCurrent = satellite.gstime(jdayCurrent);

        /*──────────────── Update TLE sprites ────────────────*/
        satellites.forEach(sat => {
            if (sat.mesh && sat.mesh.visible && sat.satrec) {
                try {
                    const pv = satellite.propagate(sat.satrec, currentTime);
                    if (!pv || !pv.position) return;
                    const ecf = satellite.eciToEcf(pv.position, gmstCurrent);
                    sat.mesh.position.set(
                        ecf.x * KM_TO_SCENE_UNITS,
                        ecf.z * KM_TO_SCENE_UNITS,
                        ecf.y * KM_TO_SCENE_UNITS
                    );
                } catch (_) {
                    sat.mesh.visible = false;
                }
            }
        });

        /*──────────────── Update detailed model ────────────────*/
        if (detailedSatelliteModel && detailedSatelliteModel.visible &&
            currentSelectedSatellite && currentSelectedSatellite.satrec) {
            try {
                const pv = satellite.propagate(currentSelectedSatellite.satrec, currentTime);
                if (pv && pv.position) {
                    const ecf = satellite.eciToEcf(pv.position, gmstCurrent);
                    detailedSatelliteModel.position.set(
                        ecf.x * KM_TO_SCENE_UNITS,
                        ecf.z * KM_TO_SCENE_UNITS,
                        ecf.y * KM_TO_SCENE_UNITS
                    );
                }
            } catch (_) { /* keep last good pos */
            }
        }

        /*──────────────── LVLH orbit‑frame arrows ────────────────*/
        if (simParams.showOrbitFrame && orbitFrame &&
            currentSelectedSatellite && currentSelectedSatellite.satrec) {
            try {
                setOrbitFrameVisibility(orbitFrame, simParams.showOrbitFrame);
                const pv = satellite.propagate(currentSelectedSatellite.satrec, currentTime);
                if (pv && pv.position && pv.velocity) {
                    const ecfPos = satellite.eciToEcf(pv.position, gmstCurrent);
                    const ecfVel = satellite.eciToEcf(pv.velocity, gmstCurrent);

                    const posVec = new THREE.Vector3(
                        ecfPos.x * KM_TO_SCENE_UNITS,
                        ecfPos.z * KM_TO_SCENE_UNITS,
                        ecfPos.y * KM_TO_SCENE_UNITS);

                    const velVec = new THREE.Vector3(
                        ecfVel.x * KM_TO_SCENE_UNITS,
                        ecfVel.z * KM_TO_SCENE_UNITS,
                        ecfVel.y * KM_TO_SCENE_UNITS);

                    updateOrbitFrame(orbitFrame, posVec, velVec);
                }
            } catch (_) { /* ignore propagation hiccups */
            }
        }

        /*──────────────── 3‑D vs Mercator views ────────────────*/
        const show3D = simParams.view3D;
        const showMercator = simParams.viewMercator;

        // 3‑D render
        if (renderer) renderer.domElement.style.display = show3D ? 'block' : 'none';
        if (show3D) {
            renderer.render(scene, camera);
            update3DLabelsPosition(camera, simParams);
        } else {
            // hide ECEF labels when 3‑D off
            ['labelXecr', 'labelYecr', 'labelZecr',
                'labelNorthPole', 'labelEquatorLine', 'labelGreenwichMeridian']
                .forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.style.display = 'none';
                });
        }

        // Mercator redraw
        if (mercatorContainer) {
            if (showMercator) {
                mercatorContainer.style.display = "block";
                if (!show3D) {
                    mercatorContainer.classList.add("fullscreen");
                } else {
                    mercatorContainer.classList.remove("fullscreen");
                }
                if (mercatorCanvasElement && mapBackgroundDiv) {
                    const currentMapContainerWidth = mapBackgroundDiv.clientWidth;
                    const currentMapContainerHeight = mapBackgroundDiv.clientHeight;
                    if (mercatorCanvasElement.width !== currentMapContainerWidth || mercatorCanvasElement.height !== currentMapContainerHeight) {
                        mercatorCanvasElement.width = currentMapContainerWidth;
                        mercatorCanvasElement.height = currentMapContainerHeight;
                    }
                    updateMercatorMap();
                }
            } else {
                mercatorContainer.style.display = "none";
            }
        }
        if (simParams.showYPR && yprFrame && currentSelectedSatellite) {
            const pos = detailedSatelliteModel
                ? detailedSatelliteModel.position
                : currentSelectedSatellite.mesh.position;

            updateYPRFrame(
                yprFrame,
                pos,
                simParams.yawDeg,
                simParams.pitchDeg,
                simParams.rollDeg
            );
        }


    }

    function onWindowResize() {
        if (camera && renderer) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        // If Mercator map is full screen or its container resizes with window, update it too
        if (mercatorContainer && mercatorContainer.style.display !== 'none' && mapBackgroundDiv) {
            const currentMapContainerWidth = mapBackgroundDiv.clientWidth;
            const currentMapContainerHeight = mapBackgroundDiv.clientHeight;
            if (mercatorCanvasElement.width !== currentMapContainerWidth || mercatorCanvasElement.height !== currentMapContainerHeight) {
                mercatorCanvasElement.width = currentMapContainerWidth;
                mercatorCanvasElement.height = currentMapContainerHeight;
                mapWidth = currentMapContainerWidth; // Update global dimension vars if used elsewhere
                mapHeight = currentMapContainerHeight;
                // updateMercatorMap(); // Redraw immediately, or let animate loop handle it
            }
        }
    }

    window.addEventListener('resize', onWindowResize);

    async function start() {
        try {

            // Now that configs are loaded (including sceneConfig), initialize 3D environment
            init3D();
            yprFrame = createYPRFrame(scene);          // after init3D()
            setYPRVisibility(yprFrame, false);
            initMercatorView(); // Initialize Mercator view (can be done after 3D)
            await setupTLESatellites(scene); // Load TLE data and create satellite sprites

            setupHTMLControls(); // Setup UI controls and their event listeners
            updateSatelliteList(); // Populate dropdowns and filter based on initial simParams
            updateECEFAxesVisibility(simParams); // Set initial visibility of ECEF axes and labels

            // Initial orbit display based on simParams and if a satellite is pre-selected (though usually not)
            if (simParams.showOrbit && currentSelectedSatellite) {
                updateOrbitTrajectory(scene, simParams, currentSelectedSatellite);
            } else {
                simParams.showOrbit = false; // Ensure it's off if no sat selected
                if (showOrbitToggle) showOrbitToggle.checked = false;
            }

            animate(); // Start the main animation loop
        } catch (e) {
            console.error("Critical error during initialization sequence:", e);
            // Display a user-friendly error message on the page
            document.body.innerHTML = `
                <div style="color:red; background:white; border: 2px solid red; padding:20px; font-family:monospace; margin: 20px;">
                    <h1>Application Initialization Failed</h1>
                    <p>A critical error occurred. Please check the browser console (usually F12) for more details.</p>
                    <pre>Error: ${e.message}</pre>
                    <p>Try refreshing the page. If the problem persists, ensure all resources (configs, TLEs, textures) are accessible (e.g., from GitHub or local paths) and that there are no network issues.</p>
                </div>`;
        }
    }

    start(); // Execute the main startup function
</script>
</body>
</html>
