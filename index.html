<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Satellite Simulation - HTML Controls</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/style.css">
    <script src="https://unpkg.com/satellite.js@4.0.0/dist/satellite.min.js"></script>
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.176.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.176.0/examples/jsm/"
          }
        }
    </script>
</head>
<body>
<button id="menuToggleBtn">âœ•</button>
<div id="ob_menu"></div>
<div id="mercatorContainer">
    <div class="mapBackground">
        <canvas id="mercatorCanvas"></canvas>
    </div>
</div>
<div id="utcClockDisplay"></div>

<script type="module">
    let usingLocalAssets;
    import * as THREE from 'three';
    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
    import {
        mercatorCanvasElement,
        mapBackgroundDiv,
        mercatorContainer,
        mapHeight,
        mapWidth,
        mercatorCtx,
        initMercatorView, updateMercatorMap
    } from './js/mercatorMapLoader.js';
    import {drawDayNight3D} from './js/drawDayNight.js';
    import {
        SATELLITES_BASE_URL,
        satelliteConfig,
        earthConfig,
        sceneConfig,
        controlsConfig,
        checkFileExists
    } from './js/SatelliteConfigurationLoader.js';
    import {updateSatelliteInfo, satelliteMenuLoader} from './js/SatelliteMenuLoader.js';
    import {
        showSatellite,
        buildAllBeams,
        clearCurrentDetailedSat,
        updateBusOrientation
    } from './js/satelliteModelLoader.js';
    import {addECEFAxes, update3DLabelsPosition, updateECEFAxesVisibility} from './js/EarthFrameLoader.js';
    import {createOrbitFrame, updateOrbitFrame, setOrbitFrameVisibility} from './js/orbitFrameLoader.js';
    import {KM_TO_SCENE_UNITS, EARTH_SCENE_RADIUS} from './js/SatelliteConstantLoader.js';
    import {satellites, updateOrbitTrajectory, setupTLESatellites, removeAllGeometry} from './js/satelliteTLELoader.js';
    import {createYPRFrame, updateYPRFrame, setYPRVisibility} from './js/satelliteYawPitchRollLoader.js';
    import {initFootprintRenderer, updateFootprints} from './js/satelliteFootprintLoader.js';

    // Load menu
    const versionNumber = "1.0m";
    const versionRepoUrl = "https://github.com/arcazj/openbexi_earth_orbit";
    const versionText = `Earth on Web - version ${versionNumber}`;
    document.getElementById('ob_menu').innerHTML = satelliteMenuLoader();

    let scene, camera, renderer, earthMesh, controls;
    let orbitFrame = null
    let currentSelectedSatellite = null; // This will store the TLE data object for the selected satellite
    let textureLoader;
    let detailedSatelliteModel = null; // This will store the THREE.Group from satelliteModelLoader
    let yprFrame;

    const simParams = {
        orbitTypeFilter: "MEO",
        companyFilter: "ALL COMPANY",
        selectedSatelliteName: "None", // Stores the name/ID from the dropdown
        showOrbit: false,
        view3D: true,
        viewMercator: false,
        useHighDefTexture: false,
        showECEFAxes: false,
        showOrbitFrame: false,
        yawDeg: 0,
        pitchDeg: 0,
        rollDeg: 0,
        showYPR: false,
        showDayNight: false,
        simDate: new Date(),
        timeWarp: 1,
        showFootprint: false
    };

    let orbitTypeFilterSelect, companyFilterSelect, satelliteCountDisplay;
    let view3DToggle, viewMercatorToggle, showOrbitToggle, showOrbitFrameToggle;
    let highDefToggleElement, showECEFAxesToggleElement, showOrbitFrameToggleElement;
    let satelliteSelectDropdown, satelliteInfoDiv;
    let controlsContainerElement, menuToggleBtnElement, versionDisplayElement;
    let labelXecrDiv, labelYecrDiv, labelZecrDiv, labelNorthPoleDiv, labelEquatorLineDiv, labelGreenwichMeridianDiv;

    simParams.timeWarp = 1 / 60;
    simParams.simDate = new Date();
    const twHTML = `
  <div id="timeWarpBox"
       style="position:fixed;bottom:5px;left:50%;transform:translateX(-50%);
              font:12px/1 sans-serif;z-index:2000;">
    <label for="timeWarpSlider">Time&nbsp;Ã—</label>
    <input type="range" id="timeWarpSlider" min="0" max="60" step="1" value="0" style="width:200px;">
    <span id="timeWarpVal">0</span>x
  </div>`;
    document.body.insertAdjacentHTML('beforeend', twHTML);
    const timeWarpSlider = document.getElementById('timeWarpSlider');
    const timeWarpVal = document.getElementById('timeWarpVal');

    function isMobileDevice() {
        return /Android|iPhone|iPad|iPod|BlackBerry|Windows Phone/i.test(navigator.userAgent || navigator.vendor || window.opera);
    }

    function updateEarthTexture() {
        if (!earthMesh || !textureLoader || !earthConfig) {
            console.warn("updateEarthTexture: Missing critical components.");
            return;
        }

        const textureToLoad = simParams.useHighDefTexture ? earthConfig.texture : earthConfig.textureLight;

        if (!textureToLoad) {
            console.error("Earth Texture URL is null. Check config paths and getFullGitHubUrl logic.");
            // Apply a very basic material if texture path is null
            earthMesh.material.map = null; // Remove any existing map
            earthMesh.material.color.set(0x1a237e); // A solid blue color
            earthMesh.material.needsUpdate = true;
            return;
        }
        console.log("Attempting to load Earth texture:", textureToLoad);

        textureLoader.load(textureToLoad,
            (texture) => {
                earthMesh.material.map = texture;
                earthMesh.material.color.set(0xffffff); // Reset color if texture loads
                earthMesh.material.needsUpdate = true;
                console.log("Earth texture successfully updated to:", textureToLoad);
            },
            undefined, // onProgress callback (optional)
            (err) => {
                //console.error('Error loading Earth texture from:', textureToLoad, err, '. Using placeholder.');
                // Fallback to a placeholder image from placehold.co
                const placeholderUrl = `https://placehold.co/${simParams.useHighDefTexture ? '4096x2048' : '1024x512'}/1c313a/ffffff?text=Earth+Texture+Load+Error`;
                textureLoader.load(placeholderUrl, (fallbackMap) => {
                    earthMesh.material.map = fallbackMap;
                    earthMesh.material.needsUpdate = true;
                });
            }
        );
    }

    function init3D() {
        /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ Scene, Camera, Renderer â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
            sceneConfig.camera.fov,
            window.innerWidth / window.innerHeight,
            sceneConfig.camera.near,
            sceneConfig.camera.far
        );
        camera.position.set(...sceneConfig.camera.position);

        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;        // allow Sun-light shadows (drawDayNight3D)
        document.body.appendChild(renderer.domElement);

        /* expose for other modules (orbitFrame labels need them) */
        window.renderer = renderer;
        window.camera = camera;

        /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ Lighting â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        scene.add(new THREE.AmbientLight(0xffffff, 0.15)); // was 0.6 or similar

        const dirLight = new THREE.DirectionalLight(
            sceneConfig.directionalLight.color,
            sceneConfig.directionalLight.intensity
        );
        dirLight.position.set(...sceneConfig.directionalLight.position);
        scene.add(dirLight);

        /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ Earth mesh â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        textureLoader = new THREE.TextureLoader();
        const earthMat = new THREE.MeshPhongMaterial({color: 0xffffff}); // texture applied later
        earthMesh = new THREE.Mesh(
            new THREE.SphereGeometry(EARTH_SCENE_RADIUS, 64, 64),
            earthMat
        );
        earthMesh.receiveShadow = true;
        scene.add(earthMesh);
        updateEarthTexture();

        /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ECEF Axes (green) â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        addECEFAxes(scene);
        updateECEFAxesVisibility(simParams);

        /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ LVLH Orbit-Frame â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        orbitFrame = createOrbitFrame(scene);          // default 10 000 km length
        setOrbitFrameVisibility(orbitFrame, false);    // hidden until toggled

        /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ OrbitControls â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = controlsConfig.enableDamping;
        controls.dampingFactor = controlsConfig.dampingFactor;
        controls.minDistance = EARTH_SCENE_RADIUS * 1.4;   // prevent inside-Earth zoom
        controls.maxDistance = EARTH_SCENE_RADIUS * 20;    // generous zoom-out
        controls.enableZoom = true;
    }

    function setupHTMLControls() {
        controlsContainerElement = document.getElementById('controlsContainer');
        menuToggleBtnElement = document.getElementById('menuToggleBtn');
        versionDisplayElement = document.getElementById('versionDisplay');

        if (versionDisplayElement) {
            versionDisplayElement.textContent = versionText;
        }

        orbitTypeFilterSelect = document.getElementById('orbitTypeFilter');
        companyFilterSelect = document.getElementById('companyFilter');
        satelliteCountDisplay = document.getElementById('satelliteCountDisplay');

        view3DToggle = document.getElementById('view3DToggle');
        viewMercatorToggle = document.getElementById('viewMercatorToggle');
        highDefToggleElement = document.getElementById('highDefToggle');
        showECEFAxesToggleElement = document.getElementById('showECEFAxesToggle');
        showOrbitFrameToggleElement = document.getElementById('showOrbitFrameToggle');
        showOrbitToggle = document.getElementById('showOrbitToggle');

        satelliteSelectDropdown = document.getElementById('satelliteSelect');
        satelliteInfoDiv = document.getElementById('satelliteInfo');

        // Axis labels
        labelXecrDiv = document.getElementById('labelXecr');
        labelYecrDiv = document.getElementById('labelYecr');
        labelZecrDiv = document.getElementById('labelZecr');
        labelNorthPoleDiv = document.getElementById('labelNorthPole');
        labelEquatorLineDiv = document.getElementById('labelEquatorLine');
        labelGreenwichMeridianDiv = document.getElementById('labelGreenwichMeridian');

        // Pitch-Roll-Yaw
        const yprControls = document.getElementById('yprControls');
        const yawSlider = document.getElementById('yawSlider');
        const pitchSlider = document.getElementById('pitchSlider');
        const rollSlider = document.getElementById('rollSlider');
        const yawVal = document.getElementById('yawVal');
        const pitchVal = document.getElementById('pitchVal');
        const rollVal = document.getElementById('rollVal');


        // Set initial values from simParams
        orbitTypeFilterSelect.value = simParams.orbitTypeFilter;
        view3DToggle.checked = simParams.view3D;
        viewMercatorToggle.checked = simParams.viewMercator;
        if (highDefToggleElement) highDefToggleElement.checked = simParams.useHighDefTexture;
        if (showECEFAxesToggleElement) showECEFAxesToggleElement.checked = simParams.showECEFAxes;
        if (showOrbitFrameToggleElement) showOrbitFrameToggleElement.checked = simParams.showOrbitFrame;
        showOrbitToggle.checked = simParams.showOrbit;

        // Timeâ€‘warp slider (Ã—1â€“60 minutes)
        timeWarpSlider.addEventListener('input', e => {
            simParams.timeWarp = parseInt(e.target.value, 10);
            if (simParams.timeWarp < 1) {
                timeWarpVal.textContent = `0`;
                simParams.timeWarp = 1 / 60;
            } else
                timeWarpVal.textContent = `${simParams.timeWarp}`;
        });

        const showFootprintChk = document.getElementById('showFootprintCheckbox');
        showFootprintChk.addEventListener('change', () => {
            simParams.showFootprint = showFootprintChk.checked;
        });


        // Event Listeners
        orbitTypeFilterSelect.addEventListener('change', (e) => {
            simParams.orbitTypeFilter = e.target.value;
            simParams.showOrbit = false; // Reset orbit display on filter change
            if (showOrbitToggle) showOrbitToggle.checked = false;
            removeAllGeometry(scene); // Clear orbit lines etc.
            updateSatelliteList(); // Refilter and update display
        });

        companyFilterSelect.addEventListener('change', (e) => {
            simParams.companyFilter = e.target.value;
            simParams.showOrbit = false; // Reset orbit display
            if (showOrbitToggle) showOrbitToggle.checked = false;
            removeAllGeometry(scene);
            updateSatelliteList();
        });

        view3DToggle.addEventListener('change', (e) => simParams.view3D = e.target.checked);
        viewMercatorToggle.addEventListener('change', (e) => simParams.viewMercator = e.target.checked);

        if (highDefToggleElement) {
            highDefToggleElement.addEventListener('change', (e) => {
                simParams.useHighDefTexture = e.target.checked;
                updateEarthTexture(); // Reload Earth texture
            });
        }
        if (showECEFAxesToggleElement) {
            showECEFAxesToggleElement.addEventListener('change', (e) => {
                simParams.showECEFAxes = e.target.checked;
                updateECEFAxesVisibility(simParams); // Toggle axes and labels
            });
        }

        if (showOrbitFrameToggleElement) {
            showOrbitFrameToggleElement.addEventListener('change', e => {
                simParams.showOrbitFrame = e.target.checked;
                if (orbitFrame) setOrbitFrameVisibility(orbitFrame, simParams.showOrbitFrame);
            });
        }

        showOrbitToggle.addEventListener('change', function(e) {
            simParams.showOrbit = e.target.checked;
            if (currentSelectedSatellite) {
                if (simParams.showOrbit) {
                    // Clear any existing orbit lines first
                    removeAllGeometry(scene);
                    // Draw new orbit
                    updateOrbitTrajectory(scene, simParams, currentSelectedSatellite);
                } else {
                    // Remove orbit lines when toggle is turned off
                    removeAllGeometry(scene);
                }
            } else {
                // If no satellite is selected, turn off the toggle
                e.target.checked = false;
                simParams.showOrbit = false;
            }
        });

        satelliteSelectDropdown.addEventListener('change', handleSatelliteDropdownChange);

        const showYPRToggle = document.getElementById('showYPRToggle');
        showYPRToggle.addEventListener('change', e => {
            const v = e.target.checked;
            simParams.showYPR = v;
            setYPRVisibility(yprFrame, v);
        });

        function updateYPRLabels() {
            yawVal.textContent = simParams.yawDeg.toFixed(1);
            pitchVal.textContent = simParams.pitchDeg.toFixed(1);
            rollVal.textContent = simParams.rollDeg.toFixed(1);
        }

        [yawSlider, pitchSlider, rollSlider].forEach(sl => {
            sl.addEventListener('input', () => {
                simParams.yawDeg = parseFloat(yawSlider.value);
                simParams.pitchDeg = parseFloat(pitchSlider.value);
                simParams.rollDeg = parseFloat(rollSlider.value);
                updateYPRLabels();
                updateBusOrientation(detailedSatelliteModel, simParams.yawDeg, simParams.pitchDeg, simParams.rollDeg);
            });
        });
        updateYPRLabels();


        // Collapsible sections
        document.querySelectorAll('#controlsContainer h3[data-collapsible-target]').forEach(header => {
            const targetId = header.dataset.collapsibleTarget;
            const targetContent = document.getElementById(targetId);
            const icon = header.querySelector('.toggle-icon');

            if (targetContent && icon) {
                // Default to expanded
                targetContent.classList.remove('collapsed');
                icon.classList.remove('collapsed');
                icon.textContent = 'â–¾'; // Down arrow for expanded

                header.addEventListener('click', () => {
                    targetContent.classList.toggle('collapsed');
                    icon.classList.toggle('collapsed');
                    icon.textContent = targetContent.classList.contains('collapsed') ? 'â–¸' : 'â–¾'; // Right for collapsed, Down for expanded
                });
            }
        });

        // Menu toggle button
        if (menuToggleBtnElement && controlsContainerElement) {
            menuToggleBtnElement.addEventListener('click', () => {
                controlsContainerElement.classList.toggle('menu-hidden');
                menuToggleBtnElement.innerHTML = controlsContainerElement.classList.contains('menu-hidden') ? 'â˜°' : 'âœ•'; // Hamburger or X
            });
            // Set initial state based on class (e.g., if 'menu-hidden' is default)
            menuToggleBtnElement.innerHTML = controlsContainerElement.classList.contains('menu-hidden') ? 'â˜°' : 'âœ•';
        }

        const showDayNightToggle = document.getElementById('showDayNightToggle');
        showDayNightToggle.checked = simParams.showDayNight;   // set UI â†¤ flag
        simParams.showDayNight = showDayNightToggle.checked;
        showDayNightToggle.addEventListener('change', e => {
            simParams.showDayNight = e.target.checked;
        });

    }

    async function handleSatelliteDropdownChange(event) {
        const selectedNameInDropdown = event.target.value;
        simParams.selectedSatelliteName = selectedNameInDropdown;

        // Clear previous satellite and orbit
        if (detailedSatelliteModel && detailedSatelliteModel.userData && detailedSatelliteModel.userData.noradId) {
            const prevTleSat = satellites.find(s => s.norad_id.toString() === detailedSatelliteModel.userData.noradId.toString());
            if (prevTleSat && prevTleSat.mesh) {
                prevTleSat.mesh.visible = true;
                prevTleSat.isSelected = false;
                prevTleSat.mesh.material.color.set(0xffffff);
                prevTleSat.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]));
            }
        }

        clearDetailedSatelliteView();
        removeAllGeometry(scene);

        if (selectedNameInDropdown === "None") {
            currentSelectedSatellite = null;
            updateSatelliteInfo(satelliteInfoDiv, null);
            resetCameraToDefault();
            updateSatelliteList();
            // Reset orbit display when no satellite is selected
            simParams.showOrbit = false;
            if (showOrbitToggle) showOrbitToggle.checked = false;
            return;
        }

        const tleSatData = satellites.find(s => s.satellite_name === selectedNameInDropdown && s.mesh && s.mesh.visible);

        if (!tleSatData) {
            console.warn(`Satellite named "${selectedNameInDropdown}" not found or not visible in current filter.`);
            currentSelectedSatellite = null;
            updateSatelliteInfo(satelliteInfoDiv, null);
            if (satelliteSelectDropdown) satelliteSelectDropdown.value = "None";
            simParams.selectedSatelliteName = "None";
            // Reset orbit display when satellite is not found
            simParams.showOrbit = false;
            if (showOrbitToggle) showOrbitToggle.checked = false;
            return;
        }

        currentSelectedSatellite = tleSatData;
        updateSatelliteInfo(satelliteInfoDiv, tleSatData);
        
        // Update orbit display based on current toggle state
        if (simParams.showOrbit) {
            updateOrbitTrajectory(scene, simParams, tleSatData);
        }

        // Attempt to load the detailed model
        let fileUrl = (usingLocalAssets ? "json/satellites/" : SATELLITES_BASE_URL) + `${tleSatData.norad_id}.json`;

        let fileExists = await checkFileExists(fileUrl);
        if (!fileExists && !usingLocalAssets) { // If GitHub primary fails, try GitHub backup structure if one existed
            console.warn(`Primary model file ${fileUrl} not found.`);
        }


        let updatedNoradId = tleSatData.norad_id;
        if (!fileExists && usingLocalAssets) { // If primary (which is local if usingLocalAssets) fails
            console.warn(`Local model file ${fileUrl} not found.`);
            // No other place to check if already local
        } else if (!fileExists && !usingLocalAssets) { // If primary GitHub failed, now try local path as a general fallback
            console.warn(`GitHub model file ${fileUrl} not found, attempting local fallback.`);
            fileUrl = "json/satellites/" + `${tleSatData.norad_id}.json`; // Standard local path
            fileExists = await checkFileExists(fileUrl);
            if (!fileExists) {
                if (selectedNameInDropdown.toLowerCase().includes('3b')) {
                    updatedNoradId = "O3b";
                    fileExists = true;
                }
                if (selectedNameInDropdown.toUpperCase().includes('IS-9')) {
                    updatedNoradId = "IS-9";
                    fileExists = true;
                }
            }
        }


        if (fileExists) {
            await loadAndDisplayDetailedSatellite(tleSatData.norad_id, tleSatData, updatedNoradId);
        } else {
            // If no specific model, try loading a generic/default model (e.g., noradId "0" or "default")
            console.warn(`Satellite data file for NORAD ${tleSatData.norad_id} not found at any checked location. Attempting to load default model.`);
            // Before loading default, ensure the selected TLE sprite is correctly highlighted
            selectSatelliteSprite(tleSatData); // Visually select the TLE sprite
            flyCameraToSatellite(tleSatData.mesh, 1000, true); // Fly to the TLE sprite

            // Optionally, try to load a "default.json" or "0.json" if you have one
            // For now, we just log and don't load a detailed model if specific one not found.
            // await loadAndDisplayDetailedSatellite("0", null); // Pass null for tleData if it's a generic model
        }

        if (selectedNameInDropdown === "None") {
            yprControls.style.display = 'none';
        } else {
            yprControls.style.display = 'block';
        }
    }

    async function loadAndDisplayDetailedSatellite(noradId, tleSatData, updatedNoradId) {
        console.log(`Attempting to load detailed model for NORAD ID: ${noradId}`);
        const newModel = await showSatellite(noradId, scene, updatedNoradId);
        const newbeams = await buildAllBeams(noradId, currentSelectedSatellite, newModel.userData.payload.transponders);

        if (newModel) {
            detailedSatelliteModel = newModel; // Store the THREE.Group
            detailedSatelliteModel.userData.noradId = noradId; // Ensure NORAD ID is stored on the model

            if (tleSatData && tleSatData.satrec) {
                currentSelectedSatellite = tleSatData; // This is the TLE data object
                tleSatData.isSelected = true; // Mark TLE data as selected
                if (tleSatData.mesh) {
                    tleSatData.mesh.visible = true; // Hide the corresponding TLE sprite
                }

                // --- Set initial position of the detailed model ---
                const now = new Date();
                const jdayNow = satellite.jday(now.getUTCFullYear(), now.getUTCMonth() + 1, now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds());
                const gmstNow = satellite.gstime(jdayNow);
                try {
                    const posVel = satellite.propagate(tleSatData.satrec, now);
                    if (posVel && posVel.position) {
                        const ecf = satellite.eciToEcf(posVel.position, gmstNow);
                        detailedSatelliteModel.position.set(ecf.x * KM_TO_SCENE_UNITS, ecf.z * KM_TO_SCENE_UNITS, ecf.y * KM_TO_SCENE_UNITS);
                        console.log(`[Detailed Model] Initial position set for ${noradId}:`, detailedSatelliteModel.position);
                    } else {
                        console.warn(`[Detailed Model] Propagation failed for initial position of ${noradId}. Model at origin.`);
                    }
                } catch (e) {
                    console.error(`[Detailed Model] Error propagating TLE for initial position of ${noradId}:`, e);
                }
                // --- End set initial position ---

            } else {
                console.warn(`[Detailed Model] TLE data or satrec missing for NORAD ${noradId}. Model loaded at origin, cannot track orbit.`);
                currentSelectedSatellite = null; // No TLE data to track
            }
            if (newbeams) {
                scene.add(newbeams);
            }

            // Deselect other TLE sprites
            satellites.forEach(s => {
                if (s !== tleSatData && s.mesh) {
                    s.isSelected = false;
                    s.mesh.material.color.set(0xffffff); // Reset color
                    s.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1])); // Reset scale
                }
            });

            flyCameraToSatellite(tleSatData.mesh, 3000, false); // Fly to the detailed model itself
            if (simParams.showOrbit && currentSelectedSatellite) {
                updateOrbitTrajectory(scene, simParams, currentSelectedSatellite);
            }

        } else {
            console.error("Failed to load detailed satellite model for NORAD ID:", noradId, "(showSatellite returned null)");
            // Fallback: ensure the TLE sprite for this satellite is selected and camera flies to it.
            if (tleSatData) {
                selectSatelliteSprite(tleSatData); // Visually select the TLE sprite
                if (tleSatData.mesh) flyCameraToSatellite(tleSatData.mesh, 1000, true); // Fly to the TLE sprite
            } else {
                if (satelliteSelectDropdown) satelliteSelectDropdown.value = "None";
                simParams.selectedSatelliteName = "None";
                currentSelectedSatellite = null;
                resetCameraToDefault();
            }
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = "position:fixed; top:10px; left:10px; padding:10px; background:orange; color:black; z-index:1000;";
            errorDiv.innerText = `Failed to load 3D model for satellite NORAD ID: ${noradId}. Displaying TLE marker.`;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 5000);
        }
    }

    function clearDetailedSatelliteView() {
        if (detailedSatelliteModel) {
            const oldNoradId = detailedSatelliteModel.userData ? detailedSatelliteModel.userData.noradId : null;
            clearCurrentDetailedSat(scene);
            scene.remove(detailedSatelliteModel);
            detailedSatelliteModel = null;

            // If a TLE sprite was hidden for this detailed model, make it visible again
            if (oldNoradId) {
                const tleSat = satellites.find(s => s.norad_id.toString() === oldNoradId.toString());
                if (tleSat && tleSat.mesh) {
                    tleSat.mesh.visible = true;
                    // Ensure its isSelected state is false if another sat isn't immediately selected
                    // This is typically handled by updateSatelliteList or selection logic
                }
            }
        }
    }


    const clock = new THREE.Clock();
    let cameraMove = null;

    /**
     * Smooth flight from the current camera position to either a sprite or a
     * detailed satellite model.  For models, we frame them at *least* the same
     * distance used for sprites so the view is consistent.
     *
     * @param {THREE.Object3D} targetObject  The sprite or model to frame.
     * @param {number} [millis=1500]         Flight duration in ms.
     * @param {boolean} [isSprite=false]     Pass true when targetObject is a sprite.
     */
    /**
     * Smooth flight from the current camera position to either a sprite or a
     * detailed satellite model.  For models, we frame them at *least* the same
     * distance used for sprites so the view is consistent.
     *
     * @param {THREE.Object3D} targetObject  The sprite or model to frame.
     * @param {number} [millis=1500]         Flight duration in ms.
     * @param {boolean} [isSprite=false]     Pass true when targetObject is a sprite.
     */
    function flyCameraToSatellite(targetObject, millis = 1500, isSprite = false) {
        if (!targetObject || !camera || !controls) {
            console.warn("flyCameraToSatellite: Missing target, camera, or controls.");
            return;
        }

        const earthCenter = new THREE.Vector3(0, 0, 0);
        const targetPos = new THREE.Vector3().setFromMatrixPosition(targetObject.matrixWorld);
        const dirToTarget = new THREE.Vector3().subVectors(targetPos, earthCenter).normalize();

        let distance;

        /* ---------- sprite path ---------- */
        if (isSprite) {
            distance = EARTH_SCENE_RADIUS * 0.5;          // fixed offset
        }

        /* ---------- detailedâ€‘model path ---------- */
        else {
            // Estimate model diameter then back off ~3Ã— that size
            const bbox = new THREE.Box3().setFromObject(targetObject);
            const size = new THREE.Vector3();
            bbox.getSize(size);
            const modelDiameter = Math.max(size.x, size.y, size.z, 0.5 * KM_TO_SCENE_UNITS * 1000);
            distance = modelDiameter;

            // Make sure we never get *closer* than the sprite framing distance
            distance = Math.max(distance, EARTH_SCENE_RADIUS * 0.5);
        }

        // Final camera position = target position + outward offset
        const endCamPos = new THREE.Vector3().addVectors(
            targetPos,
            dirToTarget.clone().multiplyScalar(distance)
        );

        /* ---------- animation setâ€‘up ---------- */
        const startCamPos = camera.position.clone();
        const startTarget = controls.target.clone();
        const endTarget = targetPos.clone();               // always look at the sat

        cameraMove = {
            startTime: clock.getElapsedTime(),
            duration: millis / 1000,
            startCamPos,
            endCamPos,
            startTarget,
            endTarget
        };

        controls.enabled = false; // reâ€‘enabled when the flight completes
        controls.reset();             // OrbitControls' builtâ€‘in reset
        camera.position.set(...sceneConfig.camera.position);
        controls.target.set(0, 0, 0);
    }

    function resetCameraToDefault() {
        if (camera && controls && sceneConfig && sceneConfig.camera && sceneConfig.camera.position) {
            // Stop any ongoing camera flight
            cameraMove = null;

            const startCamPos = camera.position.clone();
            const endCamPos = new THREE.Vector3(...sceneConfig.camera.position);
            const startTarget = controls.target.clone();
            const endTarget = new THREE.Vector3(0, 0, 0); // Look at Earth center

            cameraMove = {
                startTime: clock.getElapsedTime(),
                duration: 1.0, // 1 second to reset
                startCamPos, endCamPos,
                startTarget, endTarget
            };
            controls.enabled = false; // Disable during animation, re-enable in animate loop
        } else {
            console.warn("Cannot reset camera: camera, controls, or sceneConfig not fully initialized.");
        }
    }

    function updateSatelliteList() {
        if (!satellites || !satelliteSelectDropdown || !companyFilterSelect) {
            console.warn("updateSatelliteList: DOM elements not ready or satellites not loaded.");
            if (satelliteCountDisplay) satelliteCountDisplay.textContent = '0';
            if (satelliteSelectDropdown) satelliteSelectDropdown.innerHTML = '<option value="None">None</option>';
            if (companyFilterSelect) {
                const currentCompanyVal = companyFilterSelect.value;
                companyFilterSelect.innerHTML = '<option value="ALL COMPANY">ALL COMPANY</option>';
                if (currentCompanyVal !== "ALL COMPANY") { // Try to preserve if it was specific
                    const opt = document.createElement('option');
                    opt.value = currentCompanyVal;
                    opt.textContent = currentCompanyVal;
                    companyFilterSelect.appendChild(opt);
                    companyFilterSelect.value = currentCompanyVal;
                }
            }
            return;
        }

        const filteredTLEs = satellites.filter(s =>
            (simParams.orbitTypeFilter === "ALL" || s.orbitType === simParams.orbitTypeFilter) &&
            (simParams.companyFilter === "ALL COMPANY" || s.company === simParams.companyFilter)
        );

        // Update visibility of TLE sprites
        satellites.forEach(s => {
            if (s.mesh) {
                const isVisibleInFilter = filteredTLEs.includes(s);
                // A TLE sprite is visible if it's in the current filter AND
                // (EITHER no detailed model is shown OR the detailed model shown is NOT this TLE sprite's satellite)
                const isDetailedModelForThisSat = detailedSatelliteModel && detailedSatelliteModel.userData && detailedSatelliteModel.userData.noradId === s.norad_id.toString();
                s.mesh.visible = isVisibleInFilter && !isDetailedModelForThisSat;

                if (s.mesh.visible) { // Apply visual cues only if the sprite is visible
                    const isActuallySelected = currentSelectedSatellite === s; // s is the TLE data object
                    s.mesh.material.color.set(isActuallySelected ? 0xff0000 : 0xffffff); // Red if selected, white otherwise
                    const baseScale = satelliteConfig.scale || [0.1, 0.1, 0.1];
                    s.mesh.scale.set(...(isActuallySelected ? baseScale.map(v => v * 1.5) : baseScale));
                }
            }
        });


        if (satelliteCountDisplay) satelliteCountDisplay.textContent = filteredTLEs.length.toString();

        // Repopulate company filter based on *all* satellites, not just filtered ones, to allow broader selection
        const uniqueCompanies = Array.from(new Set(satellites.map(s => s.company))).sort();
        const currentCompanySelection = companyFilterSelect.value; // Preserve current selection if possible
        companyFilterSelect.innerHTML = '<option value="ALL COMPANY">ALL COMPANY</option>';
        uniqueCompanies.forEach(comp => {
            if (comp && comp !== "N/A") { // Filter out "N/A" or empty company names if desired
                const option = document.createElement('option');
                option.value = comp;
                option.textContent = comp;
                companyFilterSelect.appendChild(option);
            }
        });
        // Try to restore previous selection, or default to "ALL COMPANY"
        if (uniqueCompanies.includes(currentCompanySelection)) {
            companyFilterSelect.value = currentCompanySelection;
        } else {
            companyFilterSelect.value = "ALL COMPANY"; // Default if previous selection is no longer valid
            // simParams.companyFilter = "ALL COMPANY"; // Also update simParams if it changed
        }


        // Repopulate satellite dropdown based on *filtered* TLEs
        const currentDropdownValue = satelliteSelectDropdown.value; // Name of the satellite
        satelliteSelectDropdown.innerHTML = '<option value="None">None</option>';
        filteredTLEs.forEach(s => {
            const option = document.createElement('option');
            option.value = s.satellite_name; // Value is the name
            option.textContent = s.satellite_name;
            satelliteSelectDropdown.appendChild(option);
        });

        // Try to restore selection in dropdown
        if (filteredTLEs.some(s => s.satellite_name === currentDropdownValue)) {
            satelliteSelectDropdown.value = currentDropdownValue;
        } else {
            // If the previously selected satellite is no longer in the filtered list
            satelliteSelectDropdown.value = "None";
            simParams.selectedSatelliteName = "None";
            if (currentSelectedSatellite && !filteredTLEs.includes(currentSelectedSatellite)) {
                // If the actual selected object is no longer in filter, deselect it
                clearDetailedSatelliteView(); // Clear detailed model if it was for this sat
                selectSatelliteSprite(null); // Deselect TLE sprite
                currentSelectedSatellite = null;
                updateSatelliteInfo(satelliteInfoDiv, null);
            }
        }
        // If dropdown is "None" but a detailed model is showing, ensure consistency
        if (satelliteSelectDropdown.value === "None" && detailedSatelliteModel) {
            // This case should ideally be handled by the logic that sets dropdown to "None"
            // but as a safeguard:
            clearDetailedSatelliteView();
            currentSelectedSatellite = null;
            updateSatelliteInfo(satelliteInfoDiv, null);
        }
    }

    // Selects the TLE sprite (visual changes)
    function selectSatelliteSprite(tleSatData) {
        // Deselect any previously selected TLE sprite
        satellites.forEach(s => {
            if (s.mesh && s.isSelected) {
                s.isSelected = false;
                if (s.mesh.visible) { // Only change if visible
                    s.mesh.material.color.set(0xffffff);
                    s.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]));
                }
            }
        });

        currentSelectedSatellite = tleSatData; // Store the TLE data object

        if (tleSatData && tleSatData.mesh) {
            tleSatData.isSelected = true;
            if (tleSatData.mesh.visible) { // Only change if visible
                tleSatData.mesh.material.color.set(0xff0000); // Red
                tleSatData.mesh.scale.set(...(satelliteConfig.scale || [0.1, 0.1, 0.1]).map(v => v * 1.5)); // Larger
            }
            simParams.selectedSatelliteName = tleSatData.satellite_name;
            if (satelliteSelectDropdown) satelliteSelectDropdown.value = tleSatData.satellite_name;
            updateOrbitTrajectory(scene, simParams, tleSatData);
        } else {
            // Deselecting
            simParams.selectedSatelliteName = "None";
            if (satelliteSelectDropdown) satelliteSelectDropdown.value = "None";
            removeAllGeometry(scene); // Clear orbit line
        }
        updateSatelliteInfo(satelliteInfoDiv, tleSatData); // Update text info panel
    }

    window.addEventListener('keydown', e => {
        if (e.key === 'r') {            // press "r" to reset
            controls.reset();             // OrbitControls' builtâ€‘in reset
            camera.position.set(...sceneConfig.camera.position);
            controls.target.set(0, 0, 0);
        }
    });

    function formatUTCString(date) {
        const options = {
            weekday: 'short',
            year: 'numeric',
            month: 'long',
            day: '2-digit',
            timeZone: 'UTC',
        };
        const datePart = date.toLocaleDateString('en-US', options);
        const timePart = date.toUTCString().split(' ')[4]; // "HH:MM:SS"
        return `${timePart} UTC  ${datePart}`;
    }

    function animate() {
        requestAnimationFrame(animate);

        /*â”€â”€ Camera easing â”€â”€*/
        if (cameraMove) {
            const tReal = clock.getElapsedTime();
            const f = Math.min((tReal - cameraMove.startTime) / cameraMove.duration, 1);
            const s = f < 0.5 ? 2 * f * f : 1 - Math.pow(-2 * f + 2, 2) / 2;
            camera.position.lerpVectors(cameraMove.startCamPos, cameraMove.endCamPos, s);
            controls.target.lerpVectors(cameraMove.startTarget, cameraMove.endTarget, s);
            controls.update();
            if (f >= 1) {
                cameraMove = null;
                controls.enabled = true;
            }
        } else {
            controls.update();
        }

        /*â”€â”€ Simulation clock (minutesÂ·timeWarp per real-second) â”€â”€*/
        const dtReal = clock.getDelta();
        simParams.simDate = new Date(
            simParams.simDate.getTime() + dtReal * 1000 * 60 * simParams.timeWarp
        );

        const simNow = simParams.simDate;
        const jDay = satellite.jday(
            simNow.getUTCFullYear(), simNow.getUTCMonth() + 1, simNow.getUTCDate(),
            simNow.getUTCHours(), simNow.getUTCMinutes(), simNow.getUTCSeconds()
        );
        const gmstNow = satellite.gstime(jDay);
        const rotY = -gmstNow;                               // scene rotation

        /*â”€â”€ update slider read-out (factor | UTC time) â”€â”€*/
        if (timeWarpVal) {
            const pad = n => n.toString().padStart(2, '0');
            const utcStr =
                `${simNow.getUTCFullYear()}-` +
                `${pad(simNow.getUTCMonth() + 1)}-` +
                `${pad(simNow.getUTCDate())} ` +
                `${pad(simNow.getUTCHours())}:` +
                `${pad(simNow.getUTCMinutes())}:` +
                `${pad(simNow.getUTCSeconds())}`;
            document.getElementById("utcClockDisplay").textContent = formatUTCString(simParams.simDate);

            timeWarpVal.textContent = simParams.timeWarp < 1 ? '0' : `${simParams.timeWarp}`;
        }

        /*â”€â”€ Earth rotation â”€â”€*/
        if (earthMesh) earthMesh.rotation.y = rotY;

        /* helper â†’ ECF â†’ scene coords */
        const toScene = (x, y, z) =>
            new THREE.Vector3(x, z, y)
                .applyAxisAngle(new THREE.Vector3(0, 1, 0), rotY)
                .multiplyScalar(KM_TO_SCENE_UNITS);

        /*â”€â”€ Visible TLE sprites â”€â”€*/
        satellites.forEach(s => {
            if (!s.mesh?.visible || !s.satrec) return;
            try {
                const pv = satellite.propagate(s.satrec, simNow);
                if (!pv?.position) return;
                const e = satellite.eciToEcf(pv.position, gmstNow);
                s.mesh.position.copy(toScene(e.x, e.y, e.z));
            } catch { /* ignore */
            }
        });

        /*â”€â”€ Detailed model (selected) â”€â”€*/
        if (detailedSatelliteModel?.visible && currentSelectedSatellite?.satrec) {
            try {
                const pv = satellite.propagate(currentSelectedSatellite.satrec, simNow);
                if (pv?.position) {
                    const e = satellite.eciToEcf(pv.position, gmstNow);
                    detailedSatelliteModel.position.copy(toScene(e.x, e.y, e.z));
                }
            } catch { /* keep last good pos */
            }
        }

        /*â”€â”€ LVLH orbit frame (selected) â”€â”€*/
        if (simParams.showOrbitFrame &&
            orbitFrame &&
            currentSelectedSatellite?.satrec &&
            currentSelectedSatellite.mesh?.visible) {
            try {
                const pv = satellite.propagate(currentSelectedSatellite.satrec, simNow);
                if (pv?.position && pv?.velocity) {
                    const ep = satellite.eciToEcf(pv.position, gmstNow);
                    const ev = satellite.eciToEcf(pv.velocity, gmstNow);
                    updateOrbitFrame(
                        orbitFrame,
                        toScene(ep.x, ep.y, ep.z),
                        toScene(ev.x, ev.y, ev.z)
                    );
                }
            } catch { /* ignore */
            }
        }

        /*â”€â”€ YPR frame â”€â”€*/
        if (simParams.showYPR && yprFrame && currentSelectedSatellite?.mesh?.visible) {
            const pos = detailedSatelliteModel
                ? detailedSatelliteModel.position
                : currentSelectedSatellite.mesh.position;
            updateYPRFrame(
                yprFrame, pos,
                simParams.yawDeg, simParams.pitchDeg, simParams.rollDeg
            );
        }

        /*â”€â”€â”€â”€â”€â”€â”€â”€ Earth-centred "chase" camera â”€â”€â”€â”€â”€â”€â”€â”€*/
        if (!cameraMove && controls && currentSelectedSatellite?.mesh?.visible) {
            const satPos = detailedSatelliteModel
                ? detailedSatelliteModel.position
                : currentSelectedSatellite.mesh.position;

            const dir = satPos.clone().normalize();
            const camPos = satPos.clone().add(dir.multiplyScalar(EARTH_SCENE_RADIUS));
            //camera.position.copy(camPos); // if you wish to move camera itself
            controls.target.set(0, 0, 0);   // always look at Earth centre
            controls.update();
        }

        /*â”€â”€ ðŸ‘£ Footprint â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
        if (simParams.showFootprint) {
            updateFootprints(
                detailedSatelliteModel?.userData || currentSelectedSatellite,
                gmstNow,
                { showFootprint: true, mercatorCtx: null }
            );
        }
        /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/


        /*â”€â”€ Render 3-D vs Mercator â”€â”€*/
        const show3D = simParams.view3D;
        if (renderer) renderer.domElement.style.display = show3D ? 'block' : 'none';
        if (show3D) {
            renderer.render(scene, camera);
            update3DLabelsPosition(camera, simParams);
        } else {
            ['labelXecr', 'labelYecr', 'labelZecr',
                'labelNorthPole', 'labelEquatorLine', 'labelGreenwichMeridian']
                .forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.style.display = 'none';
                });
        }

        if (mercatorContainer) {
            if (simParams.viewMercator) {
                mercatorContainer.style.display = 'block';
                mercatorContainer.classList.toggle('fullscreen', !show3D);
                if (mercatorCanvasElement && mapBackgroundDiv) {
                    const w = mapBackgroundDiv.clientWidth;
                    const h = mapBackgroundDiv.clientHeight;
                    if (mercatorCanvasElement.width !== w || mercatorCanvasElement.height !== h) {
                        mercatorCanvasElement.width = w;
                        mercatorCanvasElement.height = h;
                    }
                    updateMercatorMap(simParams);
                    if (simParams.showFootprint) {
                        updateFootprints(
                            detailedSatelliteModel?.userData || currentSelectedSatellite,
                            gmstNow,
                            { showFootprint: true, mercatorCtx }
                        );
                    }
                }
            } else {
                mercatorContainer.style.display = 'none';
            }
        }

        /*â”€â”€ Day / Night shading â”€â”€*/
        if (simParams.showDayNight) {
            drawDayNight3D(scene, earthMesh, simNow, simParams.showDayNight, EARTH_SCENE_RADIUS);         // your scene-scale Earth radius);
        }
    }

    function onWindowResize() {
        if (camera && renderer) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        // If Mercator map is full screen or its container resizes with window, update it too
        if (mercatorContainer && mercatorContainer.style.display !== 'none' && mapBackgroundDiv) {
            const currentMapContainerWidth = mapBackgroundDiv.clientWidth;
            const currentMapContainerHeight = mapBackgroundDiv.clientHeight;
            if (mercatorCanvasElement.width !== currentMapContainerWidth || mercatorCanvasElement.height !== currentMapContainerHeight) {
                mercatorCanvasElement.width = currentMapContainerWidth;
                mercatorCanvasElement.height = currentMapContainerHeight;
                mapWidth = currentMapContainerWidth; // Update global dimension vars if used elsewhere
                mapHeight = currentMapContainerHeight;
                // updateMercatorMap(); // Redraw immediately, or let animate loop handle it
            }
        }
    }

    window.addEventListener('resize', onWindowResize);

    async function start() {
        try {

            // Now that configs are loaded (including sceneConfig), initialize 3D environment
            init3D();
            yprFrame = createYPRFrame(scene);          // after init3D()
            setYPRVisibility(yprFrame, false);
            initMercatorView(); // Initialize Mercator view (can be done after 3D)
            initFootprintRenderer(scene, earthMesh, mercatorCtx);
            await setupTLESatellites(scene); // Load TLE data and create satellite sprites

            setupHTMLControls(); // Setup UI controls and their event listeners
            updateSatelliteList(); // Populate dropdowns and filter based on initial simParams
            updateECEFAxesVisibility(simParams); // Set initial visibility of ECEF axes and labels

            // Initial orbit display based on simParams and if a satellite is pre-selected (though usually not)
            if (simParams.showOrbit && currentSelectedSatellite) {
                updateOrbitTrajectory(scene, simParams, currentSelectedSatellite);
            } else {
                simParams.showOrbit = false; // Ensure it's off if no sat selected
                if (showOrbitToggle) showOrbitToggle.checked = false;
            }

            animate(); // Start the main animation loop
        } catch (e) {
            console.error("Critical error during initialization sequence:", e);
            // Display a user-friendly error message on the page
            document.body.innerHTML = `
                <div style="color:red; background:white; border: 2px solid red; padding:20px; font-family:monospace; margin: 20px;">
                    <h1>Application Initialization Failed</h1>
                    <p>A critical error occurred. Please check the browser console (usually F12) for more details.</p>
                    <pre>Error: ${e.message}</pre>
                    <p>Try refreshing the page. If the problem persists, ensure all resources (configs, TLEs, textures) are accessible (e.g., from GitHub or local paths) and that there are no network issues.</p>
                </div>`;
        }
    }

    start(); // Execute the main startup function
</script>
</body>
</html>
