<!DOCTYPE html>
<html>
<head>
    <title>Three.js SES Satellite Simulation with Updated Coverage & Visibility</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        /* Ensure dat.GUI panel appears above the canvas */
        .dg { z-index: 1000 !important; }
        /* Style for the satellite info text */
        #satelliteInfo {
            margin-top: 10px;
            color: #fff;
            font-family: monospace;
            background-color: #333;
            padding: 5px;
            border-radius: 5px;
            font-size: 12px;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
<!-- Include Three.js, OrbitControls, and dat.GUI -->
<script src="https://cdn.jsdelivr.net/npm/three@latest/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dat.gui/build/dat.gui.min.js"></script>

<script>
    /**************************************************************
     * Global Variables and Configuration Objects
     **************************************************************/
    let scene, camera, renderer, earthMesh, controls;
    let satellites = []; // Array to store all satellite objects with computed parameters

    // Global configuration objects (loaded from JSON files)
    let earthConfig, constantsConfig, satelliteConfig, sceneConfig, controlsConfig;
    let globalScale; // Conversion factor: scene units per km (Earth drawn with radius 10)

    // dat.GUI parameters – including new parameters for extra options and P parameter
    let gui, guiParams = {
        orbitTypeFilter: "ALL",
        companyFilter: "ALL COMPANY",
        selectedSatellite: "",
        showOrbit: false,
        showCoverageArea: false,
        showVisibilityCone: false,
        P: 1000  // Default parameter for coverage area formula
    };
    let orbitLine = null;         // Orbit trajectory line
    let coverageCircle = null;      // Coverage area circle (on Earth's surface)
    let visibilityCone = null;      // Visibility cone mesh
    let satelliteController = null; // Dropdown controller for satellite selection
    let currentSelectedSatellite = null; // Currently selected satellite

    /**************************************************************
     * Utility Function: Load JSON
     **************************************************************/
    function fetchJSON(url) {
        return fetch(url).then(response => {
            if (!response.ok) {
                throw new Error(`Failed to load ${url}: ${response.statusText}`);
            }
            return response.json();
        });
    }

    /**************************************************************
     * Load All Configuration Files
     **************************************************************/
    async function loadConfigs() {
        [earthConfig, constantsConfig, satelliteConfig, sceneConfig, controlsConfig] =
            await Promise.all([
                fetchJSON('config/earth.json'),
                fetchJSON('config/constants.json'),
                fetchJSON('config/satellite.json'),
                fetchJSON('config/scene.json'),
                fetchJSON('config/controls.json')
            ]);
        // Set globalScale so that Earth (with radius R in km) is drawn with 10 scene units.
        globalScale = (earthConfig.diameter / 2) / 10;
    }

    /**************************************************************
     * Initialize Scene, Camera, Lights, and Earth Mesh
     **************************************************************/
    function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
            sceneConfig.camera.fov,
            window.innerWidth / window.innerHeight,
            sceneConfig.camera.near,
            sceneConfig.camera.far
        );
        camera.position.set(...sceneConfig.camera.position);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(
            sceneConfig.ambientLight.color,
            sceneConfig.ambientLight.intensity
        );
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(
            sceneConfig.directionalLight.color,
            sceneConfig.directionalLight.intensity
        );
        directionalLight.position.set(...sceneConfig.directionalLight.position);
        scene.add(directionalLight);

        // Create Earth sphere (radius 10 scene units)
        const earthRenderRadius = 10;
        const earthGeometry = new THREE.SphereGeometry(earthRenderRadius, 64, 64);
        const earthMaterial = new THREE.MeshPhongMaterial({
            map: new THREE.TextureLoader().load(earthConfig.texture)
        });
        earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
        scene.add(earthMesh);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = controlsConfig.enableDamping;
        controls.dampingFactor = controlsConfig.dampingFactor;

        // Load TLE data (new JSON format) and create satellite objects.
        setupTLESatellites('json/tle/TLE.json');

        animate();
    }

    /**************************************************************
     * Set Up Satellites from TLE Data (New Format)
     **************************************************************/
    async function setupTLESatellites(jsonFilePath) {
        try {
            const response = await fetch(jsonFilePath);
            if (!response.ok) throw new Error(`Failed to fetch TLE data: ${response.statusText}`);
            const tleData = await response.json();
            if (!Array.isArray(tleData)) throw new TypeError("TLE data is not an array");

            const textureLoader = new THREE.TextureLoader();
            const satelliteTexture = textureLoader.load(satelliteConfig.icon);
            const baseMaterial = new THREE.SpriteMaterial({ map: satelliteTexture });

            // Clear existing satellites.
            satellites.forEach(sat => scene.remove(sat.mesh));
            satellites.length = 0;

            tleData.forEach(data => {
                const { company, satellite_name, norad_id, type, launch_date, tle_line1, tle_line2 } = data;
                let orbitParams = calculateOrbitParameters(tle_line1, tle_line2);

                // Compute initial position using mean anomaly.
                const pos = new THREE.Vector3(
                    orbitParams.radiusUnits * Math.cos(orbitParams.meanAnomaly),
                    0,
                    orbitParams.radiusUnits * Math.sin(orbitParams.meanAnomaly)
                );
                pos.applyAxisAngle(new THREE.Vector3(1, 0, 0), orbitParams.inclination);
                orbitParams.position = pos;
                orbitParams.orbitRadius = pos.length();

                const satSprite = new THREE.Sprite(baseMaterial.clone());
                satSprite.scale.set(...satelliteConfig.scale);
                satSprite.position.copy(orbitParams.position);
                scene.add(satSprite);

                satellites.push({
                    mesh: satSprite,
                    company,
                    satellite_name,
                    norad_id,
                    type,
                    launch_date,
                    tle_line1,
                    tle_line2,
                    ...orbitParams
                });
            });

            createGUI();
        } catch (error) {
            console.error("Error in setupTLESatellites:", error);
        }
    }

    /**************************************************************
     * Calculate Orbital Parameters (Simplified Model)
     **************************************************************/
    function calculateOrbitParameters(tleLine1, tleLine2) {
        const mu = constantsConfig.mu;
        const R_earth = earthConfig.diameter / 2; // km

        const meanMotionRevsPerDay = parseFloat(tleLine2.slice(52, 63).trim());
        const eccentricity = parseFloat("0." + tleLine2.slice(26, 33).trim());
        const inclination = parseFloat(tleLine2.slice(8, 16).trim()) * (Math.PI / 180);
        const meanAnomalyDeg = parseFloat(tleLine2.slice(44, 51).trim());
        const meanAnomaly = meanAnomalyDeg * (Math.PI / 180);

        if (isNaN(meanMotionRevsPerDay) || isNaN(eccentricity) || isNaN(inclination) || isNaN(meanAnomaly))
            throw new Error("Invalid TLE data: Unable to parse orbital parameters.");

        const meanMotionRadPerSec = (meanMotionRevsPerDay * 2 * Math.PI) / (24 * 3600);
        const semiMajorAxisKm = Math.cbrt(mu / (meanMotionRadPerSec ** 2));
        const radiusKm = semiMajorAxisKm * (1 - eccentricity);
        const radiusUnits = radiusKm / globalScale;

        const velocityKmS = Math.sqrt(mu * (2 / radiusKm - 1 / semiMajorAxisKm));
        const velocityUnits = velocityKmS / globalScale;

        return {
            radiusUnits,
            meanAnomaly,
            velocity: velocityUnits,
            inclination,
            semiMajorAxisKm
        };
    }

    /**************************************************************
     * Create GUI Menu with Folders and Info Display
     **************************************************************/
    function createGUI() {
        gui = new dat.GUI({ autoPlace: true });

        // Create "Filters" folder.
        let filterFolder = gui.addFolder("Filters");
        filterFolder.add(guiParams, "orbitTypeFilter", ["ALL", "LEO", "MEO", "GEO"])
            .name("Orbit Type")
            .onChange(() => {
                guiParams.showOrbit = false;
                guiParams.showCoverageArea = false;
                guiParams.showVisibilityCone = false;
                toggleOrbitVisibility(false);
                toggleCoverageArea(false);
                toggleVisibilityCone(false);
                updateSatelliteList();
            });

        let companies = satellites.map(sat => sat.company);
        companies = Array.from(new Set(companies));
        companies.sort();
        companies.unshift("ALL COMPANY");
        filterFolder.add(guiParams, "companyFilter", companies)
            .name("Company")
            .onChange(() => {
                guiParams.showOrbit = false;
                guiParams.showCoverageArea = false;
                guiParams.showVisibilityCone = false;
                toggleOrbitVisibility(false);
                toggleCoverageArea(false);
                toggleVisibilityCone(false);
                updateSatelliteList();
            });
        filterFolder.open();

        // Create "Orbit Options" folder.
        let orbitFolder = gui.addFolder("Orbit Options");
        orbitFolder.add(guiParams, "showOrbit")
            .name("Show Orbit")
            .onChange(toggleOrbitVisibility);
        orbitFolder.add(guiParams, "showCoverageArea")
            .name("Show Coverage Area")
            .onChange(toggleCoverageArea);
        orbitFolder.add(guiParams, "showVisibilityCone")
            .name("Show Visibility Cone")
            .onChange(toggleVisibilityCone);
        // Add new parameter P for coverage area calculation.
        orbitFolder.add(guiParams, "P", 0, 5000)
            .name("P Parameter")
            .onChange(updateSatelliteList);
        orbitFolder.open();

        // Create satellite selection dropdown.
        updateSatelliteList();

        // Append a div for satellite info below the folders.
        let infoDiv = document.getElementById("satelliteInfo");
        if (!infoDiv) {
            infoDiv = document.createElement("div");
            infoDiv.id = "satelliteInfo";
            gui.domElement.appendChild(infoDiv);
        }

        // Reposition the close button to the bottom.
        setTimeout(() => {
            let closeButton = gui.domElement.querySelector('.close-button');
            if (closeButton) {
                gui.domElement.appendChild(closeButton);
            }
        }, 500);
    }

    /**************************************************************
     * Update Satellite List Based on Combined Filters and Reset Extra Options
     **************************************************************/
    function updateSatelliteList() {
        const filtered = satellites.filter(sat => {
            const orbitOk = (guiParams.orbitTypeFilter === "ALL") || (sat.type === guiParams.orbitTypeFilter);
            const companyOk = (guiParams.companyFilter === "ALL COMPANY") || (sat.company === guiParams.companyFilter);
            return orbitOk && companyOk;
        });
        const count = filtered.length;

        let names = ["None"].concat(filtered.map(sat => sat.satellite_name));

        // Reset extra checkboxes.
        guiParams.showOrbit = false;
        guiParams.showCoverageArea = false;
        guiParams.showVisibilityCone = false;
        toggleOrbitVisibility(false);
        toggleCoverageArea(false);
        toggleVisibilityCone(false);

        satellites.forEach(sat => {
            sat.mesh.visible = filtered.includes(sat);
            let defaultScale = satelliteConfig.scale;
            sat.mesh.scale.set(...defaultScale);
            sat.mesh.material.color.set(0xffffff);
        });

        if (satelliteController) { gui.remove(satelliteController); }
        guiParams.selectedSatellite = "None";
        satelliteController = gui.add(guiParams, "selectedSatellite", names)
            .name("Select Satellite")
            .onChange(() => {
                let sat = filtered.find(s => s.satellite_name === guiParams.selectedSatellite);
                updateSatelliteInfo(sat, count);
                if (sat) { selectSatellites(sat.satellite_name); }
            });

        updateSatelliteInfo(null, count);
    }

    /**************************************************************
     * Display Satellite Info with Header, Count, and Additional Parameters
     **************************************************************/
    function updateSatelliteInfo(sat, count) {
        let infoDiv = document.getElementById("satelliteInfo");
        if (!infoDiv) {
            infoDiv = document.createElement("div");
            infoDiv.id = "satelliteInfo";
            gui.domElement.appendChild(infoDiv);
        }
        let header = `<div style='font-weight:bold; margin-bottom:5px;'>Found ${count} Satellite(s)</div>`;
        if (!sat) {
            infoDiv.innerHTML = "<br>" + header;
            return;
        }
        // Compute coverage using the provided formula.
        const R_earth = earthConfig.diameter / 2; // km
        const d = sat.semiMajorAxisKm - R_earth; // satellite's altitude above Earth's surface in km
        const P = guiParams.P || 1000;
        const A = (50 * P) / (1 + (R_earth / d)); // coverage area in km² per provided formula
        const totalEarthArea = 4 * Math.PI * R_earth * R_earth;
        const coverageAreaPercent = (A / totalEarthArea) * 100;
        // Approximate the effective footprint radius (assuming circular area): r_foot = sqrt(A/π)
        const footprintRadius_km = Math.sqrt(A / Math.PI);
        // Coverage angle: angle subtended at Earth’s center by the footprint.
        const coverageAngleRad = 2 * Math.asin(footprintRadius_km / R_earth);
        const coverageAngleDeg = coverageAngleRad * (180 / Math.PI);
        // Altitude in km:
        const altitude_km = d;

        let info = "<br>" + header;
        info += "<table style='width:100%; border-collapse: collapse;'>";
        info += `<tr><td style='width:150px; font-weight:bold;'>Company:</td><td style='color:green;'>${sat.company}</td></tr>`;
        info += `<tr><td style='width:150px; font-weight:bold;'>Satellite Name:</td><td style='color:green;'>${sat.satellite_name}</td></tr>`;
        info += `<tr><td style='width:150px; font-weight:bold;'>NORAD ID:</td><td style='color:green;'>${sat.norad_id}</td></tr>`;
        info += `<tr><td style='width:150px; font-weight:bold;'>Type:</td><td style='color:green;'>${sat.type}</td></tr>`;
        info += `<tr><td style='width:150px; font-weight:bold;'>Launch Date:</td><td style='color:green;'>${sat.launch_date || "N/A"}</td></tr>`;
        info += `<tr><td style='width:150px; font-weight:bold;'>Altitude (km):</td><td style='color:green;'>${altitude_km.toFixed(1)}</td></tr>`;
        info += `<tr><td style='width:150px; font-weight:bold;'>Coverage Angle (°):</td><td style='color:green;'>${coverageAngleDeg.toFixed(1)}</td></tr>`;
        info += `<tr><td style='width:150px; font-weight:bold;'>Footprint Radius (km):</td><td style='color:green;'>${footprintRadius_km.toFixed(1)}</td></tr>`;
        info += `<tr><td style='width:150px; font-weight:bold;'>Coverage Area (%):</td><td style='color:green;'>${coverageAreaPercent.toFixed(1)}</td></tr>`;
        info += "</table><br>";
        info += "<table style='width:100%; border-collapse: collapse;'>";
        info += `<tr><td style='width:150px; font-weight:bold;'>TLE Line 1:</td><td style='color:yellow;'>${sat.tle_line1}</td></tr>`;
        info += `<tr><td style='width:150px; font-weight:bold;'>TLE Line 2:</td><td style='color:yellow;'>${sat.tle_line2}</td></tr>`;
        info += "</table>";

        infoDiv.innerHTML = info;
    }

    /**************************************************************
     * Function: selectSatellites (Highlighting and Blinking)
     **************************************************************/
    function selectSatellites(satName) {
        let selected = satellites.find(sat => sat.satellite_name === satName);
        if (!selected) {
            console.warn("Satellite not found: " + satName);
            currentSelectedSatellite = null;
            return;
        }
        currentSelectedSatellite = selected;
        // Reset appearance for all satellites.
        satellites.forEach(sat => {
            let defaultScale = satelliteConfig.scale;
            sat.mesh.scale.set(...defaultScale);
            sat.mesh.material.color.set(0xffffff);
        });
        // Highlight the selected satellite: increase its size.
        selected.mesh.scale.set(0.4, 0.4, 1);
        // Update camera position.
        selected.mesh.position.copy(selected.position);
        let direction = selected.mesh.position.clone().normalize();
        let cameraDistance = selected.orbitRadius + 20;
        camera.position.copy(direction.multiplyScalar(cameraDistance));
        camera.lookAt(0, 0, 0);
        controls.target.set(0, 0, 0);
        controls.update();
        // Update extra geometry if checkboxes are enabled.
        if (guiParams.showOrbit) { updateOrbitTrajectory(selected); }
        if (guiParams.showCoverageArea) { updateCoverageArea(selected); }
        if (guiParams.showVisibilityCone) { updateVisibilityCone(selected); }
    }

    /**************************************************************
     * Function: toggleOrbitVisibility
     **************************************************************/
    function toggleOrbitVisibility(value) {
        if (value) {
            let selected = satellites.find(sat => sat.satellite_name === guiParams.selectedSatellite);
            if (selected) updateOrbitTrajectory(selected);
        } else {
            if (orbitLine) { scene.remove(orbitLine); orbitLine = null; }
        }
    }

    /**************************************************************
     * Function: toggleCoverageArea
     **************************************************************/
    function toggleCoverageArea(value) {
        if (value) {
            let selected = satellites.find(sat => sat.satellite_name === guiParams.selectedSatellite);
            if (selected) updateCoverageArea(selected);
        } else {
            if (coverageCircle) { scene.remove(coverageCircle); coverageCircle = null; }
        }
    }

    /**************************************************************
     * Function: toggleVisibilityCone
     **************************************************************/
    function toggleVisibilityCone(value) {
        if (value) {
            let selected = satellites.find(sat => sat.satellite_name === guiParams.selectedSatellite);
            if (selected) updateVisibilityCone(selected);
        } else {
            if (visibilityCone) { scene.remove(visibilityCone); visibilityCone = null; }
        }
    }

    /**************************************************************
     * Function: updateOrbitTrajectory
     **************************************************************/
    function updateOrbitTrajectory(satellite) {
        if (orbitLine) { scene.remove(orbitLine); orbitLine = null; }
        const segments = 128;
        const orbitRadius = satellite.orbitRadius;
        const points = [];
        for (let i = 0; i <= segments; i++) {
            let theta = (i / segments) * 2 * Math.PI;
            let x = orbitRadius * Math.cos(theta);
            let z = orbitRadius * Math.sin(theta);
            points.push(new THREE.Vector3(x, 0, z));
        }
        const orbitGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const orbitMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 1 });
        orbitLine = new THREE.LineLoop(orbitGeometry, orbitMaterial);
        orbitLine.rotation.x = satellite.inclination;
        scene.add(orbitLine);
    }

    /**************************************************************
     * Function: updateCoverageArea (Revised)
     **************************************************************/
    function updateCoverageArea(satellite) {
        if (coverageCircle) { scene.remove(coverageCircle); coverageCircle = null; }
        const R_earth = earthConfig.diameter / 2; // km
        const d = satellite.semiMajorAxisKm - R_earth; // altitude above surface in km
        const P = guiParams.P || 1000;
        // Coverage area (A) in km² using the provided formula:
        const A = (50 * P) / (1 + (R_earth / d));
        // Effective footprint radius (assuming circular footprint): r = sqrt(A/π)
        const r_foot_km = Math.sqrt(A / Math.PI);

        // Convert Earth's radius to scene units: Earth drawn as 10.
        // The sub-satellite point (projection) is on a sphere of radius 10.
        const subSat = satellite.mesh.position.clone().normalize().multiplyScalar(10);

        // Build circle points for the coverage circle.
        const segments = 64;
        let circlePoints = [];
        // Create a circle in the X-Y plane with radius = r_foot_scene.
        // Convert r_foot_km to scene units: conversionFactor = 10 / R_earth.
        const conversionFactor = 10 / R_earth;
        const r_foot_scene = r_foot_km * conversionFactor;
        for (let i = 0; i <= segments; i++) {
            let theta = (i / segments) * 2 * Math.PI;
            let x = r_foot_scene * Math.cos(theta);
            let y = r_foot_scene * Math.sin(theta);
            circlePoints.push(new THREE.Vector3(x, y, 0));
        }
        const circleGeometry = new THREE.BufferGeometry().setFromPoints(circlePoints);
        const circleMaterial = new THREE.LineBasicMaterial({ color: 0xD3D3D3, linewidth: 1 });
        coverageCircle = new THREE.LineLoop(circleGeometry, circleMaterial);
        // Rotate the circle so that it lies horizontally (in the X-Z plane)
        coverageCircle.rotation.x = -Math.PI / 2;
        coverageCircle.position.copy(subSat);
        scene.add(coverageCircle);
    }

    /**************************************************************
     * Function: updateVisibilityCone (Revised)
     **************************************************************/
    function updateVisibilityCone(satellite) {
        const R_earth = earthConfig.diameter / 2; // Earth's radius in km
        const d = satellite.semiMajorAxisKm - R_earth; // altitude above surface in km
        const P = guiParams.P || 1000;  // Parameter P from GUI (default 1000)
        const A = (50 * P) / (1 + (R_earth / d));  // Coverage area in km² per given formula
        const r_foot_km = Math.sqrt(A / Math.PI);    // Effective footprint radius in km

        const conversionFactor = 10 / R_earth; // scene units per km (since Earth is drawn with radius 10)
        const height_scene = d * conversionFactor;    // Cone height (satellite altitude in scene units)
        const r_foot_scene = r_foot_km * conversionFactor;  // Cone base radius in scene units

        // If the cone hasn't been created yet, create it.
        if (!visibilityCone) {
            let coneGeom = new THREE.ConeGeometry(r_foot_scene, height_scene, 32, 1, true);
            // Translate the geometry so its apex is at (0,0,0)
            coneGeom.translate(0, -height_scene / 2, 0);
            const coneMat = new THREE.MeshBasicMaterial({
                color: 0xD3D3D3,
                opacity: 0.3,
                transparent: true,
                side: THREE.DoubleSide
            });
            visibilityCone = new THREE.Mesh(coneGeom, coneMat);
            scene.add(visibilityCone);
        } else {
            // (Optional) If the cone's dimensions might change (e.g. if P changes), you can recreate geometry here.
            // For simplicity we assume that for a given satellite these parameters remain constant.
        }

        // Now update the cone's orientation and position.
        let satPos = satellite.mesh.position.clone();
        // Desired direction: from the satellite toward Earth's center.
        let targetDir = satPos.clone().normalize().negate();
        // The default cone (after translation) points along (0, -1, 0).
        let defaultDir = new THREE.Vector3(0, -1, 0);
        let quaternion = new THREE.Quaternion().setFromUnitVectors(defaultDir, targetDir);
        visibilityCone.quaternion.copy(quaternion);
        // Position the cone's apex at the satellite's position.
        visibilityCone.position.copy(satPos);
    }


    // In the animate loop, call updateVisibilityCone (if enabled) so that the cone moves with the satellite:
    function animate() {
        requestAnimationFrame(animate);

        // Update positions for all satellites.
        satellites.forEach(sat => {
            let angleAdvance = sat.velocity * 0.01;
            let currentAngle = Math.atan2(sat.mesh.position.z, sat.mesh.position.x);
            let newAngle = currentAngle + angleAdvance;
            let newPos = new THREE.Vector3(
                sat.radiusUnits * Math.cos(newAngle),
                0,
                sat.radiusUnits * Math.sin(newAngle)
            );
            newPos.applyAxisAngle(new THREE.Vector3(1, 0, 0), sat.inclination);
            sat.mesh.position.copy(newPos);
        });

        // If the visibility cone is enabled and a satellite is selected, update its transform.
        if (guiParams.showVisibilityCone && currentSelectedSatellite) {
            updateVisibilityCone(currentSelectedSatellite);
        }
        // Similarly, if the coverage circle is enabled, you might want to update it too:
        if (guiParams.showCoverageArea && currentSelectedSatellite) {
            updateCoverageArea(currentSelectedSatellite);
        }

        // Blinking effect for the selected satellite.
        if (currentSelectedSatellite) {
            let now = performance.now();
            let blink = Math.floor(now / 500) % 2;
            currentSelectedSatellite.mesh.material.color.set(blink === 0 ? "#00FF00" : "#008000");
        }

        controls.update();
        renderer.render(scene, camera);
    }

    /**************************************************************
     * Handle Window Resizing
     **************************************************************/
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onWindowResize, false);

    /**************************************************************
     * Application Entry Point
     **************************************************************/
    async function start() {
        try {
            await loadConfigs();
            init();
        } catch (error) {
            console.error("Error during initialization:", error);
        }
    }
    start();
</script>
</body>
</html>
